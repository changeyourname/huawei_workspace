/*
 * cache.cpp
 *
 *  Created on: Nov 11, 2015
 *      Author: uzleo
 */




#include "cache.hpp"

cache::cache(sc_core::sc_module_name name, uint32_t num_child)
	:	sc_module(name), m_isocket("m_isocket"), m_num_child(num_child), m_evict_needed(false)
{
	m_tsocket = new tlm_utils::simple_target_socket< cache >[m_num_child];
	for (uint32_t i=0; i<m_num_child; i++) {
		m_tsocket[i].register_b_transport(this, &cache::b_transport);
	}
}


cache::~cache() {
	delete[] m_tsocket;
}


void cache::b_transport(tlm::tlm_generic_payload &trans, sc_core::sc_time &delay) {
	uint64_t addr = trans.get_address()/WORD_SIZE;
	tlm::tlm_command cmd = trans.get_command();
	unsigned char *ptr = trans.get_data_ptr();
	uint32_t len = trans.get_data_length();
	assert(len == WORD_SIZE);

	if (cache_lookup(addr)) {
		// cache hit
	} else {
		// cache miss
		if (m_evict_needed) {

		}
	}

#if 0
	cache_lookup(...)
	delay += m_lookup_delay;

	if (eviction_needed) {
		evict(...)
	}

	get_cache_block(...)
#endif

}


bool cache::cache_lookup(uint64_t addr) {
	int way_free = -1;

	uint64_t block_addr = (addr/m_cache_line_size)*m_cache_line_size;
	uint32_t set = (block_addr >> (uint32_t)(log2((double)WORD_SIZE) + log2((double)m_cache_line_size/WORD_SIZE))) & ((1 << (uint32_t)log2((double)m_num_of_sets)) - 1);
	uint64_t tag = (addr >> (uint32_t)(log2((double)WORD_SIZE) + log2((double)m_cache_line_size/WORD_SIZE) + log2((double) m_num_of_sets)));

	for (uint32_t i=0; i<m_num_of_ways; i++) {
		if (m_cache_lines[set][i].state != cache_line::I) {
			if (m_cache_lines[set][i].tag == tag) {
				if (m_log) {
					fprintf(m_fid, "cache hit for 0x%08x", (uint32_t)payload.get_address());
					frpintf(m_fid, "..tag=0x%08x", tag);
					fprintf(m_fid, "..set=%d\r\n", set);
					fflush(m_fid);			// disable this when not debugging
				}
				m_evict_needed = false;
				return true;
			}
		} else {
			way_free = i;
		}
	}
	m_evict_needed = (way_free == -1);
}






























