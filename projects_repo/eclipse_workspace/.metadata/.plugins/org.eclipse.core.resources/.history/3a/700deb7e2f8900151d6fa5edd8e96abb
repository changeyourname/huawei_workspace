/*
 * cache.cpp
 *
 *  Created on: Nov 11, 2015
 *      Author: uzleo
 */




#include "cache.hpp"

cache::cache(sc_core::sc_module_name name, uint32_t num_child)
	:	sc_module(name), m_isocket("m_isocket"), m_num_child(num_child), m_evict_needed(false)
{
	m_tsocket = new tlm_utils::simple_target_socket< cache >[m_num_child];
	for (uint32_t i=0; i<m_num_child; i++) {
		m_tsocket[i].register_b_transport(this, &cache::b_transport);
	}
}


cache::~cache() {
	delete[] m_tsocket;
}


void cache::b_transport(tlm::tlm_generic_payload &trans, sc_core::sc_time &delay) {
	uint64_t req_addr = trans.get_address();
	tlm::tlm_command cmd = trans.get_command();
	unsigned char *ptr = trans.get_data_ptr();
	uint32_t len = trans.get_data_length();
	assert(len == WORD_SIZE);
	bool evict_needed = false;

	if (cache_lookup(req_addr, evict_needed)) {
		// cache hit
		if (m_log) {
			fprintf(m_fid, "cache hit for 0x%08x", (uint32_t)payload.get_address());
			frpintf(m_fid, "..tag=0x%08x", tag);
			fprintf(m_fid, "..set=%d\r\n", set);
			fflush(m_fid);			// disable this when not debugging
		}

		// TODO: send data upstream
	} else {
		// cache miss
		if (m_log) {
			fprintf(m_fid, "cache miss for 0x%08x", (uint32_t)payload.get_address());
			fprintf(m_fid, "..tag=0x%08x", tag);
			fprintf(m_fid, "...set=%d\r\n", set);
			fflush(m_fid);			//TODO: disable this after debugging
		}

		if (evict_needed) {
			do_eviction(req_addr);
		}
	}

#if 0
	cache_lookup(...)
	delay += m_lookup_delay;

	if (eviction_needed) {
		evict(...)
	}

	get_cache_block(...)
#endif

}


void cache::blkAddr_set_tag(const uint64_t req_addr, uint64_t &block_addr, uint32_t &set, uint64_t &tag) {
	block_addr = (req_addr/m_cache_line_size)*m_cache_line_size;
	set = (block_addr >> (uint32_t)(log2((double)WORD_SIZE) + log2((double)m_cache_line_size/WORD_SIZE))) & ((1 << (uint32_t)log2((double)m_num_of_sets)) - 1);
	tag = (req_addr >> (uint32_t)(log2((double)WORD_SIZE) + log2((double)m_cache_line_size/WORD_SIZE) + log2((double) m_num_of_sets)));
}


bool cache::cache_lookup(const uint64_t req_addr, bool &evict_needed) {
	int way_free = -1;
	uint64_t block_addr, tag;
	uint32_t set;
	blkAddr_set_tag(req_addr, block_addr, set, tag);

	for (uint32_t i=0; i<m_num_of_ways; i++) {
		if (m_cache_lines[set][i].state != cache_line::I) {
			if (m_cache_lines[set][i].tag == tag) {
				evict_needed = false;
				return true;
			}
		} else {
			way_free = i;
		}
	}
	evict_needed = (way_free == -1);
}


uint32_t cache::find_way_free(const uint32_t set) {
	int way_free = -1;

	switch(m_evict) {
		case LRU:
		{
			for (uint32_t j=0; j<m_num_of_ways; j++) {
				if (m_cache_lines[set][j].evict_tag == m_num_of_ways) {
					way_free = j;
				}
			}
			assert(way_free != -1);
			break;
		}
		case LFU:
		{
			uint64_t tmp = m_cache_lines[set][0].evict_tag;
			way_free = 0;
			for (uint32_t j=1; j<m_num_of_ways; j++) {
				if (tmp > m_cache_lines[set][j].evict_tag) {
					tmp = m_cache_lines[set][j].evict_tag;
					way_free = j;
				}
			}
			break;
		}
		case RAND:
		{
			way_free = rand()%4;
			break;
		}
		case FIFO:
		{
			//TODO
			break;
		}
		default:
		{
			assert(0);
		}
	}

	return (uint32_t)way_free;
}


void cache::do_eviction(const uint64_t req_addr) {
	uint64_t block_addr, tag;
	uint32_t set;
	blkAddr_set_tag(req_addr, block_addr, set, tag);

	uint32_t way_free = find_way_free(set);

	// evicting the cache-block in way_free (found above)
	if (m_log) {
		fprintf(m_fid, "evicting way[%d]..", way_free);
		fprintf(m_fid, "tag:0x%08x..", m_cache_lines[set][way_free].tag);
		fprintf(m_fid, "lru=%d\r\n", (int)m_cache_lines[set][way_free].evict_tag);
		fflush(m_fid);			//TODO: disable this after debugging
	}

	if (m_cache_lines[set][way_free].state == cache_line::M) {
		// writing through to next higher level
		tlm::tlm_generic_payload trans;
		trans.set_write();
		trans.set_address(block_addr);
	}
}



























