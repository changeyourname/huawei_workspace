    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta http-equiv="Content-Language" content="en" />
    <link rel="stylesheet" href="doxygen.css"/>
	
	<p><b>Imperas Software Ltd. Open Virtual Platforms API Reference documentation.</b></p>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_bb678f4f19ad99ef9fc979746f4c7c82.html">include</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_18b8d8d2a97f44e49ffd47eaca92fb20.html">host</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_5fd12218c4dbe1d4fce2471012a67072.html">vmi</a>
  </div>
</div>
<div class="contents">
<h1>vmiAttrs.h</h1><a href="vmiAttrs_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> * Copyright (c) 2005-2015 Imperas Software Ltd., www.imperas.com</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * The contents of this file are provided under the Software License Agreement</span>
<a name="l00006"></a>00006 <span class="comment"> * that you accepted before downloading this file.</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> * This header forms part of the Software but may be included and used unaltered</span>
<a name="l00009"></a>00009 <span class="comment"> * in derivative works.</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> * For more information, please visit www.OVPworld.org or www.imperas.com</span>
<a name="l00012"></a>00012 <span class="comment"> */</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="comment">/******************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">/*                                                                            */</span>
<a name="l00016"></a>00016 <span class="comment">/*            V I R T U A L   M A C H I N E   I N T E R F A C E               */</span>
<a name="l00017"></a>00017 <span class="comment">/*                                                                            */</span>
<a name="l00018"></a>00018 <span class="comment">/*                      A T T R I B U T E   T Y P E S                         */</span>
<a name="l00019"></a>00019 <span class="comment">/*                                                                            */</span>
<a name="l00020"></a>00020 <span class="comment">/******************************************************************************/</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#ifndef VMI_ATTRS_H</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">#define VMI_ATTRS_H</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="simAddrTypes_8h.html">vmi/simAddrTypes.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="vmiDbg_8h.html">vmi/vmiDbg.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="vmiCxt_8h.html">vmi/vmiCxt.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="vmiCacheAttrs_8h.html">vmi/vmiCacheAttrs.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="vmiModelInfo_8h.html">vmi/vmiModelInfo.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="vmiParameters_8h.html">vmi/vmiParameters.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="vmiPorts_8h.html">vmi/vmiPorts.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="vmiTypes_8h.html">vmi/vmiTypes.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="vmiTyperefs_8h.html">vmi/vmiTyperefs.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="vmiVersion_8h.html">vmi/vmiVersion.h</a>&quot;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 
<a name="l00038"></a>00038 <span class="comment">// PROCESSOR CONSTRUCTOR &amp; DESTRUCTOR</span>
<a name="l00040"></a>00040 <span class="comment"></span>
<a name="l00041"></a>00041 <span class="comment">//</span>
<a name="l00042"></a>00042 <span class="comment">// Processor constructor</span>
<a name="l00043"></a>00043 <span class="comment">//</span>
<a name="l00044"></a><a class="code" href="vmiAttrs_8h.html#a9a02b48fa59637d3032eb09fbf96f169">00044</a> <span class="preprocessor">#define VMI_CONSTRUCTOR_FN(_NAME) void _NAME( \</span>
<a name="l00045"></a>00045 <span class="preprocessor">    vmiProcessorP  processor,           \</span>
<a name="l00046"></a>00046 <span class="preprocessor">    Bool           simulateExceptions,  \</span>
<a name="l00047"></a>00047 <span class="preprocessor">    vmiSMPContextP smpContext,          \</span>
<a name="l00048"></a>00048 <span class="preprocessor">    void          *parameterValues      \</span>
<a name="l00049"></a>00049 <span class="preprocessor">)</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a9a02b48fa59637d3032eb09fbf96f169">VMI_CONSTRUCTOR_FN</a>((*vmiConstructorFn));
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="comment">//</span>
<a name="l00053"></a>00053 <span class="comment">// Processor virtual memory initialization</span>
<a name="l00054"></a>00054 <span class="comment">//</span>
<a name="l00055"></a><a class="code" href="vmiAttrs_8h.html#a3bf546ba1237b9f89626d9211020b474">00055</a> <span class="preprocessor">#define VMI_VMINIT_FN(_NAME) void _NAME( \</span>
<a name="l00056"></a>00056 <span class="preprocessor">    vmiProcessorP  processor,            \</span>
<a name="l00057"></a>00057 <span class="preprocessor">    memDomainPP    codeDomains,          \</span>
<a name="l00058"></a>00058 <span class="preprocessor">    memDomainPP    dataDomains           \</span>
<a name="l00059"></a>00059 <span class="preprocessor">)</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a3bf546ba1237b9f89626d9211020b474">VMI_VMINIT_FN</a>((*vmiVMInitFn));
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="comment">//</span>
<a name="l00063"></a>00063 <span class="comment">// Processor destructor</span>
<a name="l00064"></a>00064 <span class="comment">//</span>
<a name="l00065"></a><a class="code" href="vmiAttrs_8h.html#a53761b5cbbc80f7d9987b113cea8b7d6">00065</a> <span class="preprocessor">#define VMI_DESTRUCTOR_FN(_NAME) void _NAME(vmiProcessorP processor)</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a53761b5cbbc80f7d9987b113cea8b7d6">VMI_DESTRUCTOR_FN</a>((*vmiDestructorFn));
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 
<a name="l00070"></a>00070 <span class="comment">// SAVE / RESTORE</span>
<a name="l00072"></a>00072 <span class="comment"></span>
<a name="l00073"></a>00073 <span class="comment">//</span>
<a name="l00074"></a>00074 <span class="comment">// This callback function type is used to implement processor save</span>
<a name="l00075"></a>00075 <span class="comment">//</span>
<a name="l00076"></a><a class="code" href="vmiAttrs_8h.html#af2e58c90e28b1ea0fc231a2b1c57e52b">00076</a> <span class="preprocessor">#define VMI_SAVE_STATE_FN(_NAME) void _NAME( \</span>
<a name="l00077"></a>00077 <span class="preprocessor">    vmiProcessorP       processor,  \</span>
<a name="l00078"></a>00078 <span class="preprocessor">    vmiSaveContextP     cxt,        \</span>
<a name="l00079"></a>00079 <span class="preprocessor">    vmiSaveRestorePhase phase       \</span>
<a name="l00080"></a>00080 <span class="preprocessor">)</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#af2e58c90e28b1ea0fc231a2b1c57e52b">VMI_SAVE_STATE_FN</a>((*vmiSaveStateFn));
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="comment">//</span>
<a name="l00084"></a>00084 <span class="comment">// This callback function type is used to implement processor restore</span>
<a name="l00085"></a>00085 <span class="comment">//</span>
<a name="l00086"></a><a class="code" href="vmiAttrs_8h.html#a0f62ad2ae145f66ab2d2f4195fb3ccb6">00086</a> <span class="preprocessor">#define VMI_RESTORE_STATE_FN(_NAME) void _NAME( \</span>
<a name="l00087"></a>00087 <span class="preprocessor">    vmiProcessorP       processor,  \</span>
<a name="l00088"></a>00088 <span class="preprocessor">    vmiRestoreContextP  cxt,        \</span>
<a name="l00089"></a>00089 <span class="preprocessor">    vmiSaveRestorePhase phase       \</span>
<a name="l00090"></a>00090 <span class="preprocessor">)</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a0f62ad2ae145f66ab2d2f4195fb3ccb6">VMI_RESTORE_STATE_FN</a>((*vmiRestoreStateFn));
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 
<a name="l00095"></a>00095 <span class="comment">// SIMULATED PROCESSOR ACTION CALLBACKS</span>
<a name="l00097"></a>00097 <span class="comment"></span>
<a name="l00098"></a>00098 <span class="comment">//</span>
<a name="l00099"></a>00099 <span class="comment">// This callback function type defines functions that are called just before</span>
<a name="l00100"></a>00100 <span class="comment">// a code block translation starts (startBlockCB) and just after a block</span>
<a name="l00101"></a>00101 <span class="comment">// translation completes (endBlockCB). The callbacks may be used to initialize</span>
<a name="l00102"></a>00102 <span class="comment">// and finalize data structures required by the translation function below.</span>
<a name="l00103"></a>00103 <span class="comment">//</span>
<a name="l00104"></a><a class="code" href="vmiAttrs_8h.html#ac72bf8854a3d7f1e7bd4e7908615f7dd">00104</a> <span class="preprocessor">#define VMI_START_END_BLOCK_FN(_NAME) void _NAME( \</span>
<a name="l00105"></a>00105 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00106"></a>00106 <span class="preprocessor">    Addr          thisPC,       \</span>
<a name="l00107"></a>00107 <span class="preprocessor">    Uns8          inDelaySlot   \</span>
<a name="l00108"></a>00108 <span class="preprocessor">)</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#ac72bf8854a3d7f1e7bd4e7908615f7dd">VMI_START_END_BLOCK_FN</a>((*vmiStartEndBlockFn));
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="comment">//</span>
<a name="l00112"></a>00112 <span class="comment">// This callback function type defines a function used to translate a single</span>
<a name="l00113"></a>00113 <span class="comment">// processor instruction.</span>
<a name="l00114"></a>00114 <span class="comment">//</span>
<a name="l00115"></a><a class="code" href="vmiAttrs_8h.html#a932e10d1261d3bbc4ca3ab9f11668471">00115</a> <span class="preprocessor">#define VMI_MORPH_FN(_NAME) void _NAME( \</span>
<a name="l00116"></a>00116 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00117"></a>00117 <span class="preprocessor">    Addr          thisPC,       \</span>
<a name="l00118"></a>00118 <span class="preprocessor">    Uns8          inDelaySlot,  \</span>
<a name="l00119"></a>00119 <span class="preprocessor">    Bool          firstInBlock, \</span>
<a name="l00120"></a>00120 <span class="preprocessor">    Bool          emitTrace     \</span>
<a name="l00121"></a>00121 <span class="preprocessor">)</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a932e10d1261d3bbc4ca3ab9f11668471">VMI_MORPH_FN</a>((*vmiMorphFn));
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="comment">//</span>
<a name="l00125"></a>00125 <span class="comment">// This callback function type defines a function that is called instead of the</span>
<a name="l00126"></a>00126 <span class="comment">// vmiMorphFn above for instructions that have been opaquely intercepted. The</span>
<a name="l00127"></a>00127 <span class="comment">// purpose of the function is to allow processor state to be updated even if</span>
<a name="l00128"></a>00128 <span class="comment">// the instruction implementation is elsewhere.</span>
<a name="l00129"></a>00129 <span class="comment">//</span>
<a name="l00130"></a><a class="code" href="vmiAttrs_8h.html#ac477d92c6b41758e2a999cda267cedeb">00130</a> <span class="preprocessor">#define VMI_POST_OPAQUE_FN(_NAME) void _NAME( \</span>
<a name="l00131"></a>00131 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00132"></a>00132 <span class="preprocessor">    Addr          thisPC,       \</span>
<a name="l00133"></a>00133 <span class="preprocessor">    Uns8          inDelaySlot   \</span>
<a name="l00134"></a>00134 <span class="preprocessor">)</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#ac477d92c6b41758e2a999cda267cedeb">VMI_POST_OPAQUE_FN</a>((*vmiPostOpaqueFn));
<a name="l00136"></a>00136 
<a name="l00137"></a>00137 <span class="comment">//</span>
<a name="l00138"></a>00138 <span class="comment">// This callback function type defines a routine that is called to snap</span>
<a name="l00139"></a>00139 <span class="comment">// instruction fetch addresses if required</span>
<a name="l00140"></a>00140 <span class="comment">//</span>
<a name="l00141"></a><a class="code" href="vmiAttrs_8h.html#a2bab2b5643bf833105e24e57195ec219">00141</a> <span class="preprocessor">#define VMI_FETCH_SNAP_FN(_NAME) Addr _NAME( \</span>
<a name="l00142"></a>00142 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00143"></a>00143 <span class="preprocessor">    Addr          thisPC        \</span>
<a name="l00144"></a>00144 <span class="preprocessor">)</span>
<a name="l00145"></a>00145 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a2bab2b5643bf833105e24e57195ec219">VMI_FETCH_SNAP_FN</a>((*vmiFetchSnapFn));
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="comment">//</span>
<a name="l00148"></a>00148 <span class="comment">// Callback to handle misaligned read or write accesses when these should either</span>
<a name="l00149"></a>00149 <span class="comment">// cause the read/write address to be snapped or cause the read/written value to</span>
<a name="l00150"></a>00150 <span class="comment">// be rotated, or both. The return value should be constructed using the</span>
<a name="l00151"></a>00151 <span class="comment">// MEM_SNAP macro defined in vmiTypes.h. A return value of zero indicates no</span>
<a name="l00152"></a>00152 <span class="comment">// address snapping or rotation is required and that the read alignment</span>
<a name="l00153"></a>00153 <span class="comment">// exception handler should be called.</span>
<a name="l00154"></a>00154 <span class="comment">//</span>
<a name="l00155"></a><a class="code" href="vmiAttrs_8h.html#a3abe4edc3cb3b94bf032ee3ccff089a5">00155</a> <span class="preprocessor">#define VMI_RD_WR_SNAP_FN(_NAME) Uns32 _NAME( \</span>
<a name="l00156"></a>00156 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00157"></a>00157 <span class="preprocessor">    Addr          address,      \</span>
<a name="l00158"></a>00158 <span class="preprocessor">    Uns32         bytes         \</span>
<a name="l00159"></a>00159 <span class="preprocessor">)</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a3abe4edc3cb3b94bf032ee3ccff089a5">VMI_RD_WR_SNAP_FN</a>((*vmiRdWrSnapFn));
<a name="l00161"></a>00161 
<a name="l00162"></a>00162 <span class="comment">//</span>
<a name="l00163"></a>00163 <span class="comment">// Callback to handle memory read privilege exceptions</span>
<a name="l00164"></a>00164 <span class="comment">//</span>
<a name="l00165"></a><a class="code" href="vmiAttrs_8h.html#a2e07ec801c21e40612cf3c9e944b1486">00165</a> <span class="preprocessor">#define VMI_RD_PRIV_EXCEPT_FN(_NAME) void _NAME( \</span>
<a name="l00166"></a>00166 <span class="preprocessor">    vmiProcessorP       processor,  \</span>
<a name="l00167"></a>00167 <span class="preprocessor">    memDomainP          domain,     \</span>
<a name="l00168"></a>00168 <span class="preprocessor">    Addr                address,    \</span>
<a name="l00169"></a>00169 <span class="preprocessor">    Uns32               bytes,      \</span>
<a name="l00170"></a>00170 <span class="preprocessor">    void               *value,      \</span>
<a name="l00171"></a>00171 <span class="preprocessor">    memAccessAttrs      attrs,      \</span>
<a name="l00172"></a>00172 <span class="preprocessor">    vmiLoadStoreAction *action      \</span>
<a name="l00173"></a>00173 <span class="preprocessor">)</span>
<a name="l00174"></a>00174 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a2e07ec801c21e40612cf3c9e944b1486">VMI_RD_PRIV_EXCEPT_FN</a>((*vmiRdPrivExceptFn));
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="comment">//</span>
<a name="l00177"></a>00177 <span class="comment">// Callback to handle memory write privilege exceptions</span>
<a name="l00178"></a>00178 <span class="comment">//</span>
<a name="l00179"></a><a class="code" href="vmiAttrs_8h.html#aad91911f5a806a7aa5f2e1385f055a48">00179</a> <span class="preprocessor">#define VMI_WR_PRIV_EXCEPT_FN(_NAME) void _NAME( \</span>
<a name="l00180"></a>00180 <span class="preprocessor">    vmiProcessorP       processor,  \</span>
<a name="l00181"></a>00181 <span class="preprocessor">    memDomainP          domain,     \</span>
<a name="l00182"></a>00182 <span class="preprocessor">    Addr                address,    \</span>
<a name="l00183"></a>00183 <span class="preprocessor">    Uns32               bytes,      \</span>
<a name="l00184"></a>00184 <span class="preprocessor">    const void         *value,      \</span>
<a name="l00185"></a>00185 <span class="preprocessor">    memAccessAttrs      attrs,      \</span>
<a name="l00186"></a>00186 <span class="preprocessor">    vmiLoadStoreAction *action      \</span>
<a name="l00187"></a>00187 <span class="preprocessor">)</span>
<a name="l00188"></a>00188 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#aad91911f5a806a7aa5f2e1385f055a48">VMI_WR_PRIV_EXCEPT_FN</a>((*vmiWrPrivExceptFn));
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 <span class="comment">//</span>
<a name="l00191"></a>00191 <span class="comment">// Callback to handle memory read alignment exceptions.</span>
<a name="l00192"></a>00192 <span class="comment">//</span>
<a name="l00193"></a><a class="code" href="vmiAttrs_8h.html#a79f7b2ac8517455ea952e50209da885a">00193</a> <span class="preprocessor">#define VMI_RD_ALIGN_EXCEPT_FN(_NAME) Uns32 _NAME( \</span>
<a name="l00194"></a>00194 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00195"></a>00195 <span class="preprocessor">    memDomainP    domain,       \</span>
<a name="l00196"></a>00196 <span class="preprocessor">    Addr          address,      \</span>
<a name="l00197"></a>00197 <span class="preprocessor">    Uns32         bytes,        \</span>
<a name="l00198"></a>00198 <span class="preprocessor">    void         *value         \</span>
<a name="l00199"></a>00199 <span class="preprocessor">)</span>
<a name="l00200"></a>00200 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a79f7b2ac8517455ea952e50209da885a">VMI_RD_ALIGN_EXCEPT_FN</a>((*vmiRdAlignExceptFn));
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 <span class="comment">//</span>
<a name="l00203"></a>00203 <span class="comment">// Callback to handle memory write alignment exceptions.</span>
<a name="l00204"></a>00204 <span class="comment">//</span>
<a name="l00205"></a><a class="code" href="vmiAttrs_8h.html#a969909130cef69618af6aedb80c08df2">00205</a> <span class="preprocessor">#define VMI_WR_ALIGN_EXCEPT_FN(_NAME) Uns32 _NAME( \</span>
<a name="l00206"></a>00206 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00207"></a>00207 <span class="preprocessor">    memDomainP    domain,       \</span>
<a name="l00208"></a>00208 <span class="preprocessor">    Addr          address,      \</span>
<a name="l00209"></a>00209 <span class="preprocessor">    Uns32         bytes,        \</span>
<a name="l00210"></a>00210 <span class="preprocessor">    const void   *value         \</span>
<a name="l00211"></a>00211 <span class="preprocessor">)</span>
<a name="l00212"></a>00212 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a969909130cef69618af6aedb80c08df2">VMI_WR_ALIGN_EXCEPT_FN</a>((*vmiWrAlignExceptFn));
<a name="l00213"></a>00213 
<a name="l00214"></a>00214 <span class="comment">//</span>
<a name="l00215"></a>00215 <span class="comment">// Callback to handle memory read abort exceptions (generated by calls to</span>
<a name="l00216"></a>00216 <span class="comment">// icmAbortRead in memory read callbacks). isFetch is True if this is an</span>
<a name="l00217"></a>00217 <span class="comment">// instruction fetch and False otherwise.</span>
<a name="l00218"></a>00218 <span class="comment">//</span>
<a name="l00219"></a><a class="code" href="vmiAttrs_8h.html#ad0e8e25f0e8f9da76de98993948ed3c9">00219</a> <span class="preprocessor">#define VMI_RD_ABORT_EXCEPT_FN(_NAME) void _NAME( \</span>
<a name="l00220"></a>00220 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00221"></a>00221 <span class="preprocessor">    Addr          address,      \</span>
<a name="l00222"></a>00222 <span class="preprocessor">    Bool          isFetch       \</span>
<a name="l00223"></a>00223 <span class="preprocessor">)</span>
<a name="l00224"></a>00224 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#ad0e8e25f0e8f9da76de98993948ed3c9">VMI_RD_ABORT_EXCEPT_FN</a>((*vmiRdAbortExceptFn));
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 <span class="comment">//</span>
<a name="l00227"></a>00227 <span class="comment">// Callback to handle memory write abort exceptions (generated by calls to</span>
<a name="l00228"></a>00228 <span class="comment">// icmAbortWrite in memory read callbacks).</span>
<a name="l00229"></a>00229 <span class="comment">//</span>
<a name="l00230"></a><a class="code" href="vmiAttrs_8h.html#ab8d0454ebfc4e5bf2d28aab159f59f87">00230</a> <span class="preprocessor">#define VMI_WR_ABORT_EXCEPT_FN(_NAME) void _NAME( \</span>
<a name="l00231"></a>00231 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00232"></a>00232 <span class="preprocessor">    Addr          address       \</span>
<a name="l00233"></a>00233 <span class="preprocessor">)</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#ab8d0454ebfc4e5bf2d28aab159f59f87">VMI_WR_ABORT_EXCEPT_FN</a>((*vmiWrAbortExceptFn));
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="comment">//</span>
<a name="l00237"></a>00237 <span class="comment">// Callback to handle illegal device memory read exceptions.</span>
<a name="l00238"></a>00238 <span class="comment">//</span>
<a name="l00239"></a><a class="code" href="vmiAttrs_8h.html#a65d92301ec81946278494c6b41641880">00239</a> <span class="preprocessor">#define VMI_RD_DEVICE_EXCEPT_FN(_NAME) Bool _NAME( \</span>
<a name="l00240"></a>00240 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00241"></a>00241 <span class="preprocessor">    memDomainP    domain,       \</span>
<a name="l00242"></a>00242 <span class="preprocessor">    Addr          address,      \</span>
<a name="l00243"></a>00243 <span class="preprocessor">    Uns32         bytes,        \</span>
<a name="l00244"></a>00244 <span class="preprocessor">    void         *value         \</span>
<a name="l00245"></a>00245 <span class="preprocessor">)</span>
<a name="l00246"></a>00246 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a65d92301ec81946278494c6b41641880">VMI_RD_DEVICE_EXCEPT_FN</a>((*vmiRdDeviceExceptFn));
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="comment">//</span>
<a name="l00249"></a>00249 <span class="comment">// Callback to handle illegal device memory write exceptions.</span>
<a name="l00250"></a>00250 <span class="comment">//</span>
<a name="l00251"></a><a class="code" href="vmiAttrs_8h.html#a00418ba705c250babeb4ca19cc0dbab5">00251</a> <span class="preprocessor">#define VMI_WR_DEVICE_EXCEPT_FN(_NAME) Bool _NAME( \</span>
<a name="l00252"></a>00252 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00253"></a>00253 <span class="preprocessor">    memDomainP    domain,       \</span>
<a name="l00254"></a>00254 <span class="preprocessor">    Addr          address,      \</span>
<a name="l00255"></a>00255 <span class="preprocessor">    Uns32         bytes,        \</span>
<a name="l00256"></a>00256 <span class="preprocessor">    const void   *value         \</span>
<a name="l00257"></a>00257 <span class="preprocessor">)</span>
<a name="l00258"></a>00258 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a00418ba705c250babeb4ca19cc0dbab5">VMI_WR_DEVICE_EXCEPT_FN</a>((*vmiWrDeviceExceptFn));
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 <span class="comment">//</span>
<a name="l00261"></a>00261 <span class="comment">// Callback for integer exception handler</span>
<a name="l00262"></a>00262 <span class="comment">// Return value indicates how the exception was handled</span>
<a name="l00263"></a>00263 <span class="comment">//</span>
<a name="l00264"></a><a class="code" href="vmiAttrs_8h.html#a5c5b65f3958a4ccd0a81e01e94b1169f">00264</a> <span class="preprocessor">#define VMI_ARITH_EXCEPT_FN(_NAME) vmiIntegerExceptionResult _NAME( \</span>
<a name="l00265"></a>00265 <span class="preprocessor">    vmiProcessorP           processor,          \</span>
<a name="l00266"></a>00266 <span class="preprocessor">    vmiIntegerExceptionType exceptionType,      \</span>
<a name="l00267"></a>00267 <span class="preprocessor">    vmiExceptionContext     exceptionContext    \</span>
<a name="l00268"></a>00268 <span class="preprocessor">)</span>
<a name="l00269"></a>00269 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a5c5b65f3958a4ccd0a81e01e94b1169f">VMI_ARITH_EXCEPT_FN</a>((*vmiArithExceptFn));
<a name="l00270"></a>00270 
<a name="l00271"></a>00271 <span class="comment">//</span>
<a name="l00272"></a>00272 <span class="comment">// Callback for fetch exception handler for an instruction fetch at the passed</span>
<a name="l00273"></a>00273 <span class="comment">// address. If no exception is pending, return VMI_FETCH_NONE. If an exception</span>
<a name="l00274"></a>00274 <span class="comment">// is pending and the machine state has been modified to handle it, return</span>
<a name="l00275"></a>00275 <span class="comment">// VMI_FETCH_EXCEPTION_COMPLETE.</span>
<a name="l00276"></a>00276 <span class="comment">//</span>
<a name="l00277"></a>00277 <span class="comment">// If it is required that the register dump associated with the instruction</span>
<a name="l00278"></a>00278 <span class="comment">// causing the exception should show the processor state *before* it is updated,</span>
<a name="l00279"></a>00279 <span class="comment">// return VMI_FETCH_EXCEPTION_PENDING (without updating processor state) if</span>
<a name="l00280"></a>00280 <span class="comment">// &apos;complete&apos; is False. The register dump will then be emitted and the fetch</span>
<a name="l00281"></a>00281 <span class="comment">// exception handler called a second time with the &apos;complete&apos; argument set to</span>
<a name="l00282"></a>00282 <span class="comment">// True indicating that the machine state should be updated</span>
<a name="l00283"></a>00283 <span class="comment">//</span>
<a name="l00284"></a><a class="code" href="vmiAttrs_8h.html#aae4d6ee2e33a7b3f4cadc2d950cc6338">00284</a> <span class="preprocessor">#define VMI_IFETCH_FN(_NAME) vmiFetchAction _NAME( \</span>
<a name="l00285"></a>00285 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00286"></a>00286 <span class="preprocessor">    memDomainP    domain,       \</span>
<a name="l00287"></a>00287 <span class="preprocessor">    Addr          address,      \</span>
<a name="l00288"></a>00288 <span class="preprocessor">    Bool          complete,     \</span>
<a name="l00289"></a>00289 <span class="preprocessor">    Bool          annulled      \</span>
<a name="l00290"></a>00290 <span class="preprocessor">)</span>
<a name="l00291"></a>00291 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#aae4d6ee2e33a7b3f4cadc2d950cc6338">VMI_IFETCH_FN</a>((*vmiIFetchFn));
<a name="l00292"></a>00292 
<a name="l00293"></a>00293 <span class="comment">//</span>
<a name="l00294"></a>00294 <span class="comment">// Return the current processor endianness for instruction (if isFetch is True)</span>
<a name="l00295"></a>00295 <span class="comment">// or data (if isFetch is False)</span>
<a name="l00296"></a>00296 <span class="comment">//</span>
<a name="l00297"></a><a class="code" href="vmiAttrs_8h.html#aa506767f50638ddecb4f9b59a1ee14bd">00297</a> <span class="preprocessor">#define VMI_ENDIAN_FN(_NAME) memEndian _NAME( \</span>
<a name="l00298"></a>00298 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00299"></a>00299 <span class="preprocessor">    Bool          isFetch       \</span>
<a name="l00300"></a>00300 <span class="preprocessor">)</span>
<a name="l00301"></a>00301 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#aa506767f50638ddecb4f9b59a1ee14bd">VMI_ENDIAN_FN</a>((*vmiEndianFn));
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 <span class="comment">//</span>
<a name="l00304"></a>00304 <span class="comment">// Return the next instruction address after the current address</span>
<a name="l00305"></a>00305 <span class="comment">//</span>
<a name="l00306"></a><a class="code" href="vmiAttrs_8h.html#a67637341b0061314dfda209fdb4c573b">00306</a> <span class="preprocessor">#define VMI_NEXT_PC_FN(_NAME) Addr _NAME(vmiProcessorP processor, Addr thisPC)</span>
<a name="l00307"></a>00307 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a67637341b0061314dfda209fdb4c573b">VMI_NEXT_PC_FN</a>((*vmiNextPCFn));
<a name="l00308"></a>00308 
<a name="l00309"></a>00309 <span class="comment">//</span>
<a name="l00310"></a>00310 <span class="comment">// Return a string representing the disassembled instruction at the passed</span>
<a name="l00311"></a>00311 <span class="comment">// address</span>
<a name="l00312"></a>00312 <span class="comment">//</span>
<a name="l00313"></a><a class="code" href="vmiAttrs_8h.html#a22df34d616d415505590678292f7d150">00313</a> <span class="preprocessor">#define VMI_DISASSEMBLE_FN(_NAME) const char *_NAME( \</span>
<a name="l00314"></a>00314 <span class="preprocessor">    vmiProcessorP  processor,   \</span>
<a name="l00315"></a>00315 <span class="preprocessor">    Addr           thisPC,      \</span>
<a name="l00316"></a>00316 <span class="preprocessor">    vmiDisassAttrs attrs        \</span>
<a name="l00317"></a>00317 <span class="preprocessor">)</span>
<a name="l00318"></a>00318 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a22df34d616d415505590678292f7d150">VMI_DISASSEMBLE_FN</a>((*vmiDisassFn));
<a name="l00319"></a>00319 
<a name="l00320"></a>00320 <span class="comment">//</span>
<a name="l00321"></a>00321 <span class="comment">// This callback is called on a processor context switch. &apos;state&apos; describes the</span>
<a name="l00322"></a>00322 <span class="comment">// new state.</span>
<a name="l00323"></a>00323 <span class="comment">//</span>
<a name="l00324"></a><a class="code" href="vmiAttrs_8h.html#a1e7357467691f7c7347d4055516d08df">00324</a> <span class="preprocessor">#define VMI_IASSWITCH_FN(_NAME) void _NAME( \</span>
<a name="l00325"></a>00325 <span class="preprocessor">    vmiProcessorP  processor,   \</span>
<a name="l00326"></a>00326 <span class="preprocessor">    vmiIASRunState state        \</span>
<a name="l00327"></a>00327 <span class="preprocessor">)</span>
<a name="l00328"></a>00328 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a1e7357467691f7c7347d4055516d08df">VMI_IASSWITCH_FN</a>((*vmiIASSwitchFn));
<a name="l00329"></a>00329 
<a name="l00330"></a>00330 <span class="comment">//</span>
<a name="l00331"></a>00331 <span class="comment">// This callback should create code to cause a processor to return from an</span>
<a name="l00332"></a>00332 <span class="comment">// opaque intercept</span>
<a name="l00333"></a>00333 <span class="comment">//</span>
<a name="l00334"></a><a class="code" href="vmiAttrs_8h.html#a38ab2d5bb67141b894ed97ab7bc9a3fb">00334</a> <span class="preprocessor">#define VMI_INT_RETURN_FN(_NAME) void _NAME( \</span>
<a name="l00335"></a>00335 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00336"></a>00336 <span class="preprocessor">    Addr          thisPC        \</span>
<a name="l00337"></a>00337 <span class="preprocessor">)</span>
<a name="l00338"></a>00338 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a38ab2d5bb67141b894ed97ab7bc9a3fb">VMI_INT_RETURN_FN</a>((*vmiintReturnFn));
<a name="l00339"></a>00339 
<a name="l00340"></a>00340 <span class="comment">//</span>
<a name="l00341"></a>00341 <span class="comment">// This callback should create code to assign the function result of an</span>
<a name="l00342"></a>00342 <span class="comment">// Imperas intercepted call to the result register of the processor, using the</span>
<a name="l00343"></a>00343 <span class="comment">// standard processor procedure call ABI. The function result type is described</span>
<a name="l00344"></a>00344 <span class="comment">// by the passed format argument, which can be any of the following:</span>
<a name="l00345"></a>00345 <span class="comment">//</span>
<a name="l00346"></a>00346 <span class="comment">//      &apos;4&apos;:    4-byte result (e.g. Uns32 type)</span>
<a name="l00347"></a>00347 <span class="comment">//      &apos;8&apos;:    8-byte result (e.g. Uns64 type)</span>
<a name="l00348"></a>00348 <span class="comment">//</span>
<a name="l00349"></a><a class="code" href="vmiAttrs_8h.html#a2a935ebc7d468cc3950eaba839e25f64">00349</a> <span class="preprocessor">#define VMI_INT_RESULT_FN(_NAME) void _NAME( \</span>
<a name="l00350"></a>00350 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00351"></a>00351 <span class="preprocessor">    char          format        \</span>
<a name="l00352"></a>00352 <span class="preprocessor">)</span>
<a name="l00353"></a>00353 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a2a935ebc7d468cc3950eaba839e25f64">VMI_INT_RESULT_FN</a>((*vmiintResultFn));
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 <span class="comment">//</span>
<a name="l00356"></a>00356 <span class="comment">// This callback should create code to push function parameters before making</span>
<a name="l00357"></a>00357 <span class="comment">// an Imperas intercepted call. The function parameters are presented using the</span>
<a name="l00358"></a>00358 <span class="comment">// standard processor procedure call ABI. The function parameters are described</span>
<a name="l00359"></a>00359 <span class="comment">// by the passed format string. This string can contain a sequence of any of the</span>
<a name="l00360"></a>00360 <span class="comment">// following:</span>
<a name="l00361"></a>00361 <span class="comment">//</span>
<a name="l00362"></a>00362 <span class="comment">//      &apos;4&apos;:    push Uns32 function argument using vmimtArgReg(32, ...)</span>
<a name="l00363"></a>00363 <span class="comment">//      &apos;8&apos;:    push Uns64 function argument using vmimtArgReg(64, ...)</span>
<a name="l00364"></a>00364 <span class="comment">//      &apos;a&apos;:    push address function argument using vmimtArgRegSimAddress(...)</span>
<a name="l00365"></a>00365 <span class="comment">//      &apos;d&apos;:    push Flt64 function argument using vmimtArgFlt64(...)</span>
<a name="l00366"></a>00366 <span class="comment">//</span>
<a name="l00367"></a>00367 <span class="comment">// For example, a format string of &quot;84a&quot; requires arguments to be pushed for a</span>
<a name="l00368"></a>00368 <span class="comment">// function that takes an 8-byte argument followed by a 4-byte argument followed</span>
<a name="l00369"></a>00369 <span class="comment">// by an address argument.</span>
<a name="l00370"></a>00370 <span class="comment">//</span>
<a name="l00371"></a><a class="code" href="vmiAttrs_8h.html#a69d6c3805c7005094128b183059683da">00371</a> <span class="preprocessor">#define VMI_INT_PAR_FN(_NAME) void _NAME( \</span>
<a name="l00372"></a>00372 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00373"></a>00373 <span class="preprocessor">    const char   *format        \</span>
<a name="l00374"></a>00374 <span class="preprocessor">)</span>
<a name="l00375"></a>00375 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a69d6c3805c7005094128b183059683da">VMI_INT_PAR_FN</a>((*vmiintParFn));
<a name="l00376"></a>00376 
<a name="l00377"></a>00377 <span class="comment">//</span>
<a name="l00378"></a>00378 <span class="comment">// Invoke encapsulated simulator to simulate for &apos;count&apos; instructions. Return</span>
<a name="l00379"></a>00379 <span class="comment">// the number of instructions actually executed.</span>
<a name="l00380"></a>00380 <span class="comment">//</span>
<a name="l00381"></a><a class="code" href="vmiAttrs_8h.html#a17e7276e3863dc6cddc125850ddc4017">00381</a> <span class="preprocessor">#define VMI_ENCAP_SIM_FN(_NAME) Uns32 _NAME( \</span>
<a name="l00382"></a>00382 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00383"></a>00383 <span class="preprocessor">    Uns32         count         \</span>
<a name="l00384"></a>00384 <span class="preprocessor">)</span>
<a name="l00385"></a>00385 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a17e7276e3863dc6cddc125850ddc4017">VMI_ENCAP_SIM_FN</a>((*vmiEncapSimFn));
<a name="l00386"></a>00386 
<a name="l00387"></a>00387 <span class="comment">//</span>
<a name="l00388"></a>00388 <span class="comment">// Get program counter for encapsulated simulator processor</span>
<a name="l00389"></a>00389 <span class="comment">//</span>
<a name="l00390"></a><a class="code" href="vmiAttrs_8h.html#a03c7bf9dab482060b0384f7e4cb142fd">00390</a> <span class="preprocessor">#define VMI_ENCAP_GET_PC_FN(_NAME) Addr _NAME( \</span>
<a name="l00391"></a>00391 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00392"></a>00392 <span class="preprocessor">    Uns8         *slotD         \</span>
<a name="l00393"></a>00393 <span class="preprocessor">)</span>
<a name="l00394"></a>00394 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a03c7bf9dab482060b0384f7e4cb142fd">VMI_ENCAP_GET_PC_FN</a>((*vmiEncapGetPCFn));
<a name="l00395"></a>00395 
<a name="l00396"></a>00396 <span class="comment">//</span>
<a name="l00397"></a>00397 <span class="comment">// Get instruction count for encapsulated simulator processor</span>
<a name="l00398"></a>00398 <span class="comment">//</span>
<a name="l00399"></a><a class="code" href="vmiAttrs_8h.html#a8e2c982d1eb1761278a5b3f02c2748d6">00399</a> <span class="preprocessor">#define VMI_ENCAP_ICOUNT_FN(_NAME) Uns64 _NAME(vmiProcessorP processor)</span>
<a name="l00400"></a>00400 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a8e2c982d1eb1761278a5b3f02c2748d6">VMI_ENCAP_ICOUNT_FN</a>((*vmiEncapICountFn));
<a name="l00401"></a>00401 
<a name="l00402"></a>00402 <span class="comment">//</span>
<a name="l00403"></a>00403 <span class="comment">// Type of function called by simulator to get the size of the parameter value</span>
<a name="l00404"></a>00404 <span class="comment">// table</span>
<a name="l00405"></a>00405 <span class="comment">//</span>
<a name="l00406"></a><a class="code" href="vmiAttrs_8h.html#a1ff6531886d905ac213b28dcbe5e4b05">00406</a> <span class="preprocessor">#define VMI_PROC_PARAM_TABLE_SIZE_FN(_NAME) Uns32 _NAME ( \</span>
<a name="l00407"></a>00407 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00408"></a>00408 <span class="preprocessor">    const char   *variant       \</span>
<a name="l00409"></a>00409 <span class="preprocessor">)</span>
<a name="l00410"></a>00410 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a1ff6531886d905ac213b28dcbe5e4b05">VMI_PROC_PARAM_TABLE_SIZE_FN</a>((*vmiParamValueSizeFn));
<a name="l00411"></a>00411 
<a name="l00412"></a>00412 <span class="comment">//</span>
<a name="l00413"></a>00413 <span class="comment">// Type of function called by simulator to get info about the parameters of this</span>
<a name="l00414"></a>00414 <span class="comment">// model</span>
<a name="l00415"></a>00415 <span class="comment">//</span>
<a name="l00416"></a><a class="code" href="vmiAttrs_8h.html#a1cee601f9403ac4f41d89c568ad9c2f3">00416</a> <span class="preprocessor">#define VMI_PROC_PARAM_SPECS_FN(_NAME) vmiParameterP _NAME ( \</span>
<a name="l00417"></a>00417 <span class="preprocessor">    vmiProcessorP processor,    \</span>
<a name="l00418"></a>00418 <span class="preprocessor">    vmiParameterP prev          \</span>
<a name="l00419"></a>00419 <span class="preprocessor">)</span>
<a name="l00420"></a>00420 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="vmiAttrs_8h.html#a1cee601f9403ac4f41d89c568ad9c2f3">VMI_PROC_PARAM_SPECS_FN</a>((*vmiParamSpecsFn));
<a name="l00421"></a>00421 
<a name="l00422"></a>00422 <span class="comment">//</span>
<a name="l00423"></a>00423 <span class="comment">// This structure describes attributes for instruction-accurate modeling for a</span>
<a name="l00424"></a>00424 <span class="comment">// particular processor</span>
<a name="l00425"></a>00425 <span class="comment">//</span>
<a name="l00426"></a><a class="code" href="structvmiIASAttrS.html">00426</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structvmiIASAttrS.html">vmiIASAttrS</a> {
<a name="l00427"></a>00427 
<a name="l00429"></a>00429     <span class="comment">// VERSION &amp; TYPE</span>
<a name="l00431"></a>00431 <span class="comment"></span>
<a name="l00432"></a><a class="code" href="structvmiIASAttrS.html#aa47fbb12708e9f886e7852df14eb1791">00432</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>      *<a class="code" href="structvmiIASAttrS.html#aa47fbb12708e9f886e7852df14eb1791">versionString</a>;      <span class="comment">// version string (THIS MUST BE FIRST)</span>
<a name="l00433"></a><a class="code" href="structvmiIASAttrS.html#a42d03d713fa2e217fe25f61d30380c12">00433</a>     <a class="code" href="vmiTypes_8h.html#add6c0bfa67acb5c121405c66f785994a">vmiModelType</a>     <a class="code" href="structvmiIASAttrS.html#a42d03d713fa2e217fe25f61d30380c12">modelType</a>;          <span class="comment">// model type (THIS MUST BE SECOND)</span>
<a name="l00434"></a>00434 
<a name="l00436"></a>00436     <span class="comment">// MODEL STATUS</span>
<a name="l00438"></a>00438 <span class="comment"></span>
<a name="l00439"></a><a class="code" href="structvmiIASAttrS.html#a3564321f2f5b1ffaf7e2e6b06daf1848">00439</a>     <a class="code" href="vmiTypes_8h.html#a952ea301b165ead407f288be768a2fe8">vmiVisibility</a>    <a class="code" href="structvmiIASAttrS.html#a3564321f2f5b1ffaf7e2e6b06daf1848">visibility</a>;         <span class="comment">// model instance invisibility (enum)</span>
<a name="l00440"></a><a class="code" href="structvmiIASAttrS.html#ae4a1e6fddcbbe105c9962528d6c0b360">00440</a>     <a class="code" href="vmiTypes_8h.html#aab7894df69709d1f89a90d231a7a1946">vmiReleaseStatus</a> <a class="code" href="structvmiIASAttrS.html#ae4a1e6fddcbbe105c9962528d6c0b360">releaseStatus</a>;      <span class="comment">// model release status (enum)</span>
<a name="l00441"></a>00441 
<a name="l00443"></a>00443     <span class="comment">// SIZE ATTRIBUTES</span>
<a name="l00445"></a>00445 <span class="comment"></span>
<a name="l00446"></a><a class="code" href="structvmiIASAttrS.html#a7dadbbb447310b1d91405a0cae5feb94">00446</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>    **<a class="code" href="structvmiIASAttrS.html#a7dadbbb447310b1d91405a0cae5feb94">dictNames</a>;          <span class="comment">// null-terminated dictionary name list</span>
<a name="l00447"></a><a class="code" href="structvmiIASAttrS.html#a69a5a595cfc7fd64705e73174117a96f">00447</a>     <a class="code" href="impTypes_8h.html#a206d2eb5f751c4e68e2281af9d79db64">Uns32</a>           <a class="code" href="structvmiIASAttrS.html#a69a5a595cfc7fd64705e73174117a96f">cpuSize</a>;            <span class="comment">// full size of CPU object</span>
<a name="l00448"></a>00448 
<a name="l00450"></a>00450     <span class="comment">// SAVE/RESTORE ROUTINES</span>
<a name="l00452"></a>00452 <span class="comment"></span>
<a name="l00453"></a><a class="code" href="structvmiIASAttrS.html#a3a92c6f5fb6c4607c0df60c4526a95f5">00453</a>     vmiSaveStateFn    <a class="code" href="structvmiIASAttrS.html#a3a92c6f5fb6c4607c0df60c4526a95f5">saveCB</a>;           <span class="comment">// processor state save callback</span>
<a name="l00454"></a><a class="code" href="structvmiIASAttrS.html#a3bda7c3fc4009f426cc0830243e52885">00454</a>     vmiRestoreStateFn <a class="code" href="structvmiIASAttrS.html#a3bda7c3fc4009f426cc0830243e52885">restoreCB</a>;        <span class="comment">// processor state restore callback</span>
<a name="l00455"></a>00455 
<a name="l00457"></a>00457     <span class="comment">// CONSTRUCTOR/DESTRUCTOR ROUTINES</span>
<a name="l00459"></a>00459 <span class="comment"></span>
<a name="l00460"></a><a class="code" href="structvmiIASAttrS.html#a7f6b7d9b48a41380899a4c08157a70da">00460</a>     vmiConstructorFn <a class="code" href="structvmiIASAttrS.html#a7f6b7d9b48a41380899a4c08157a70da">constructorCB</a>;     <span class="comment">// constructor</span>
<a name="l00461"></a><a class="code" href="structvmiIASAttrS.html#a3891de87f43b59326c05fb474341ee82">00461</a>     vmiVMInitFn      <a class="code" href="structvmiIASAttrS.html#a3891de87f43b59326c05fb474341ee82">vmInitCB</a>;          <span class="comment">// virtual memory initialization</span>
<a name="l00462"></a><a class="code" href="structvmiIASAttrS.html#aca8c74cb02bb59910f92af9a2c971f19">00462</a>     vmiDestructorFn  <a class="code" href="structvmiIASAttrS.html#aca8c74cb02bb59910f92af9a2c971f19">destructorCB</a>;      <span class="comment">// destructor</span>
<a name="l00463"></a>00463 
<a name="l00465"></a>00465     <span class="comment">// MORPHER CORE ROUTINES</span>
<a name="l00467"></a>00467 <span class="comment"></span>
<a name="l00468"></a><a class="code" href="structvmiIASAttrS.html#a72ed9cbffeeff85b1adccf531fcbd90d">00468</a>     vmiStartEndBlockFn <a class="code" href="structvmiIASAttrS.html#a72ed9cbffeeff85b1adccf531fcbd90d">startBlockCB</a>;    <span class="comment">// called before block translate</span>
<a name="l00469"></a><a class="code" href="structvmiIASAttrS.html#aadc7e31db41941eb8d9914f4eec80d17">00469</a>     vmiStartEndBlockFn <a class="code" href="structvmiIASAttrS.html#aadc7e31db41941eb8d9914f4eec80d17">endBlockCB</a>;      <span class="comment">// called after block translate</span>
<a name="l00470"></a><a class="code" href="structvmiIASAttrS.html#ae7c60d60c5d89a8e515c2136661c5c8e">00470</a>     vmiMorphFn         <a class="code" href="structvmiIASAttrS.html#ae7c60d60c5d89a8e515c2136661c5c8e">morphCB</a>;         <span class="comment">// morph callback</span>
<a name="l00471"></a><a class="code" href="structvmiIASAttrS.html#a78ebee9cfb6df9e66792d876dddac783">00471</a>     vmiPostOpaqueFn    <a class="code" href="structvmiIASAttrS.html#a78ebee9cfb6df9e66792d876dddac783">postOpaqueCB</a>;    <span class="comment">// called after opaque intercept</span>
<a name="l00472"></a><a class="code" href="structvmiIASAttrS.html#a94fefc4447846c8611b33f03b7eda981">00472</a>     vmiFetchSnapFn     <a class="code" href="structvmiIASAttrS.html#a94fefc4447846c8611b33f03b7eda981">fetchSnapCB</a>;     <span class="comment">// fetch address snap callback</span>
<a name="l00473"></a><a class="code" href="structvmiIASAttrS.html#a5734d48d41735cc32c9805e28456b476">00473</a>     vmiRdWrSnapFn      <a class="code" href="structvmiIASAttrS.html#a5734d48d41735cc32c9805e28456b476">rdSnapCB</a>;        <span class="comment">// read alignment snap function</span>
<a name="l00474"></a><a class="code" href="structvmiIASAttrS.html#aa3145ce99488dc490bdf0b2543d273f0">00474</a>     vmiRdWrSnapFn      <a class="code" href="structvmiIASAttrS.html#aa3145ce99488dc490bdf0b2543d273f0">wrSnapCB</a>;        <span class="comment">// write alignment snap function</span>
<a name="l00475"></a>00475 
<a name="l00477"></a>00477     <span class="comment">// SIMULATION SUPPORT ROUTINES</span>
<a name="l00479"></a>00479 <span class="comment"></span>
<a name="l00480"></a><a class="code" href="structvmiIASAttrS.html#a1d4c5ec87808ea1f4b568726a3ad52ae">00480</a>     vmiEndianFn    <a class="code" href="structvmiIASAttrS.html#a1d4c5ec87808ea1f4b568726a3ad52ae">getEndianCB</a>;         <span class="comment">// get processor endianness</span>
<a name="l00481"></a><a class="code" href="structvmiIASAttrS.html#a401734ee82635c0f52759bdac2307906">00481</a>     vmiNextPCFn    <a class="code" href="structvmiIASAttrS.html#a401734ee82635c0f52759bdac2307906">nextPCCB</a>;            <span class="comment">// get next instruction address</span>
<a name="l00482"></a><a class="code" href="structvmiIASAttrS.html#a7147dfecce266f28c62250773ab3bb7e">00482</a>     vmiDisassFn    <a class="code" href="structvmiIASAttrS.html#a7147dfecce266f28c62250773ab3bb7e">disCB</a>;               <span class="comment">// disassemble instruction</span>
<a name="l00483"></a><a class="code" href="structvmiIASAttrS.html#a02fa388bdd39dbba848dc5bd951ed05e">00483</a>     vmiIASSwitchFn <a class="code" href="structvmiIASAttrS.html#a02fa388bdd39dbba848dc5bd951ed05e">switchCB</a>;            <span class="comment">// call on simulator context switch</span>
<a name="l00484"></a>00484 
<a name="l00486"></a>00486     <span class="comment">// EXCEPTION ROUTINES</span>
<a name="l00488"></a>00488 <span class="comment"></span>
<a name="l00489"></a><a class="code" href="structvmiIASAttrS.html#a83e72ff26b0ab5decff2ca63c306475d">00489</a>     vmiRdPrivExceptFn   <a class="code" href="structvmiIASAttrS.html#a83e72ff26b0ab5decff2ca63c306475d">rdPrivExceptCB</a>;     <span class="comment">// read privilege exception</span>
<a name="l00490"></a><a class="code" href="structvmiIASAttrS.html#a15ace9911052855960076097216ba4cc">00490</a>     vmiWrPrivExceptFn   <a class="code" href="structvmiIASAttrS.html#a15ace9911052855960076097216ba4cc">wrPrivExceptCB</a>;     <span class="comment">// write privilege exception</span>
<a name="l00491"></a><a class="code" href="structvmiIASAttrS.html#a84897ca282c1e278f57e9c6ff017ab95">00491</a>     vmiRdAlignExceptFn  <a class="code" href="structvmiIASAttrS.html#a84897ca282c1e278f57e9c6ff017ab95">rdAlignExceptCB</a>;    <span class="comment">// read alignment exception</span>
<a name="l00492"></a><a class="code" href="structvmiIASAttrS.html#a6bb2c8429bca3a90e2245c377721809c">00492</a>     vmiWrAlignExceptFn  <a class="code" href="structvmiIASAttrS.html#a6bb2c8429bca3a90e2245c377721809c">wrAlignExceptCB</a>;    <span class="comment">// write alignment exception</span>
<a name="l00493"></a><a class="code" href="structvmiIASAttrS.html#a5fb02741e786bf63572e000a90f48248">00493</a>     vmiRdAbortExceptFn  <a class="code" href="structvmiIASAttrS.html#a5fb02741e786bf63572e000a90f48248">rdAbortExceptCB</a>;    <span class="comment">// read abort exception</span>
<a name="l00494"></a><a class="code" href="structvmiIASAttrS.html#a401c6fbca1cdefe1a4389f8ee73a4efc">00494</a>     vmiWrAbortExceptFn  <a class="code" href="structvmiIASAttrS.html#a401c6fbca1cdefe1a4389f8ee73a4efc">wrAbortExceptCB</a>;    <span class="comment">// write abort exception</span>
<a name="l00495"></a><a class="code" href="structvmiIASAttrS.html#ab630028db705026b49e4e3d16726f4a0">00495</a>     vmiRdDeviceExceptFn <a class="code" href="structvmiIASAttrS.html#ab630028db705026b49e4e3d16726f4a0">rdDeviceExceptCB</a>;   <span class="comment">// read device exception</span>
<a name="l00496"></a><a class="code" href="structvmiIASAttrS.html#a2f99ef5233805c6cd0638766f805e647">00496</a>     vmiWrDeviceExceptFn <a class="code" href="structvmiIASAttrS.html#a2f99ef5233805c6cd0638766f805e647">wrDeviceExceptCB</a>;   <span class="comment">// write device exception</span>
<a name="l00497"></a><a class="code" href="structvmiIASAttrS.html#af01b0e1da40e1595895df1a8bbac6cd1">00497</a>     vmiIFetchFn         <a class="code" href="structvmiIASAttrS.html#af01b0e1da40e1595895df1a8bbac6cd1">ifetchExceptCB</a>;     <span class="comment">// execution privilege exception</span>
<a name="l00498"></a><a class="code" href="structvmiIASAttrS.html#a05ca8bef54bef9e3e5f42732b5b3cfbd">00498</a>     vmiArithExceptFn    <a class="code" href="structvmiIASAttrS.html#a05ca8bef54bef9e3e5f42732b5b3cfbd">arithExceptCB</a>;      <span class="comment">// arithmetic exception</span>
<a name="l00499"></a><a class="code" href="structvmiIASAttrS.html#a949d2862b6a4be50378b92e3336d9b7e">00499</a>     vmiICountFn         <a class="code" href="structvmiIASAttrS.html#a949d2862b6a4be50378b92e3336d9b7e">icountExceptCB</a>;     <span class="comment">// instruction count exception</span>
<a name="l00500"></a>00500 
<a name="l00502"></a>00502     <span class="comment">// DEBUGGER INTEGRATION SUPPORT ROUTINES</span>
<a name="l00504"></a>00504 <span class="comment"></span>
<a name="l00505"></a><a class="code" href="structvmiIASAttrS.html#ae4f12bccfee33d33aecea901e2979b83">00505</a>     vmiRegGroupFn      <a class="code" href="structvmiIASAttrS.html#ae4f12bccfee33d33aecea901e2979b83">regGroupCB</a>;      <span class="comment">// regGroup callback</span>
<a name="l00506"></a><a class="code" href="structvmiIASAttrS.html#a5e9b5fc0d788b468521bb700d829f858">00506</a>     vmiRegInfoFn       <a class="code" href="structvmiIASAttrS.html#a5e9b5fc0d788b468521bb700d829f858">regInfoCB</a>;       <span class="comment">// regInfo callback</span>
<a name="l00507"></a><a class="code" href="structvmiIASAttrS.html#af2caae45033f60f376237f36893824a1">00507</a>     vmiExceptionInfoFn <a class="code" href="structvmiIASAttrS.html#af2caae45033f60f376237f36893824a1">exceptionInfoCB</a>; <span class="comment">// exceptionInfo callback</span>
<a name="l00508"></a><a class="code" href="structvmiIASAttrS.html#a0daadaa3c2e1101e20e0abd05d96b82e">00508</a>     vmiModeInfoFn      <a class="code" href="structvmiIASAttrS.html#a0daadaa3c2e1101e20e0abd05d96b82e">modeInfoCB</a>;      <span class="comment">// modeInfo callback</span>
<a name="l00509"></a><a class="code" href="structvmiIASAttrS.html#ad7944ae201d7054b0f74040511341f0e">00509</a>     vmiGetExceptionFn  <a class="code" href="structvmiIASAttrS.html#ad7944ae201d7054b0f74040511341f0e">getExceptionCB</a>;  <span class="comment">// return current processor exception</span>
<a name="l00510"></a><a class="code" href="structvmiIASAttrS.html#ab905d5a673aa0f47abf78d16a23b223b">00510</a>     vmiGetModeFn       <a class="code" href="structvmiIASAttrS.html#ab905d5a673aa0f47abf78d16a23b223b">getModeCB</a>;       <span class="comment">// return current processor mode</span>
<a name="l00511"></a><a class="code" href="structvmiIASAttrS.html#ac03f0175ddb286f43d2687def1527098">00511</a>     vmiRegReadFn       <a class="code" href="structvmiIASAttrS.html#ac03f0175ddb286f43d2687def1527098">regReadCB</a>;       <span class="comment">// default regRead callback</span>
<a name="l00512"></a><a class="code" href="structvmiIASAttrS.html#af971100f7adb06c36e0d5df3cc06a74a">00512</a>     vmiRegWriteFn      <a class="code" href="structvmiIASAttrS.html#af971100f7adb06c36e0d5df3cc06a74a">regWriteCB</a>;      <span class="comment">// default regWrite callback</span>
<a name="l00513"></a><a class="code" href="structvmiIASAttrS.html#aabca4d2cde3802c12059858c5f8d7fe9">00513</a>     vmiTraceFn         <a class="code" href="structvmiIASAttrS.html#aabca4d2cde3802c12059858c5f8d7fe9">traceCB</a>;         <span class="comment">// model-specific instruction trace</span>
<a name="l00514"></a><a class="code" href="structvmiIASAttrS.html#aabb259b60b9f647d0fc13698b457e7cf">00514</a>     vmiDebugFn         <a class="code" href="structvmiIASAttrS.html#aabb259b60b9f647d0fc13698b457e7cf">debugCB</a>;         <span class="comment">// model-specific register dump</span>
<a name="l00515"></a><a class="code" href="structvmiIASAttrS.html#a84b5c5d5c6b2204aa74eee9dcf998bd4">00515</a>     vmiProcDescFn      <a class="code" href="structvmiIASAttrS.html#a84b5c5d5c6b2204aa74eee9dcf998bd4">procDescCB</a>;      <span class="comment">// processor description callback</span>
<a name="l00516"></a>00516 
<a name="l00518"></a>00518     <span class="comment">// PARAMETER SUPPORT ROUTINES iterator to find the parameters</span>
<a name="l00520"></a>00520 <span class="comment"></span>
<a name="l00521"></a><a class="code" href="structvmiIASAttrS.html#a4648486f9ff60b325b12c3be511270f5">00521</a>     vmiParamSpecsFn     <a class="code" href="structvmiIASAttrS.html#a4648486f9ff60b325b12c3be511270f5">paramSpecsCB</a>;     <span class="comment">// next parameter callback</span>
<a name="l00522"></a><a class="code" href="structvmiIASAttrS.html#a52e2ee9d1b743b9a496fe30fdbd885de">00522</a>     vmiParamValueSizeFn <a class="code" href="structvmiIASAttrS.html#a52e2ee9d1b743b9a496fe30fdbd885de">paramValueSizeCB</a>; <span class="comment">// size of parameter values table</span>
<a name="l00523"></a>00523 
<a name="l00525"></a>00525     <span class="comment">// PORT ACCESS ROUTINES iterators to find the bus and net ports</span>
<a name="l00527"></a>00527 <span class="comment"></span>
<a name="l00528"></a><a class="code" href="structvmiIASAttrS.html#a89c1644477647a893fe58f8ae6e61127">00528</a>     vmiBusPortSpecsFn   <a class="code" href="structvmiIASAttrS.html#a89c1644477647a893fe58f8ae6e61127">busPortSpecsCB</a>;     <span class="comment">// callback for next bus port</span>
<a name="l00529"></a><a class="code" href="structvmiIASAttrS.html#a047efd394cb1e88d0111153fbe609675">00529</a>     vmiNetPortSpecsFn   <a class="code" href="structvmiIASAttrS.html#a047efd394cb1e88d0111153fbe609675">netPortSpecsCB</a>;     <span class="comment">// callback for next net port</span>
<a name="l00530"></a><a class="code" href="structvmiIASAttrS.html#a0b8af53aa2e3f156e062eeb40eceb58b">00530</a>     vmiFifoPortSpecsFn  <a class="code" href="structvmiIASAttrS.html#a0b8af53aa2e3f156e062eeb40eceb58b">fifoPortSpecsCB</a>;    <span class="comment">// callback for next fifo port</span>
<a name="l00531"></a>00531 
<a name="l00533"></a>00533     <span class="comment">// IMPERAS INTERCEPTED FUNCTION SUPPORT ROUTINES</span>
<a name="l00535"></a>00535 <span class="comment"></span>
<a name="l00536"></a><a class="code" href="structvmiIASAttrS.html#acf9f835eaf6749b843fab38e9534edbf">00536</a>     vmiintReturnFn <a class="code" href="structvmiIASAttrS.html#acf9f835eaf6749b843fab38e9534edbf">intReturnCB</a>;         <span class="comment">// morph return from opaque intercept</span>
<a name="l00537"></a><a class="code" href="structvmiIASAttrS.html#a1c8bfb72bf681a67c2d1cadd32f097fc">00537</a>     vmiintResultFn <a class="code" href="structvmiIASAttrS.html#a1c8bfb72bf681a67c2d1cadd32f097fc">intResultCB</a>;         <span class="comment">// set intercepted function result</span>
<a name="l00538"></a><a class="code" href="structvmiIASAttrS.html#ade226d0a495e134d589ffdc5baa45235">00538</a>     vmiintParFn    <a class="code" href="structvmiIASAttrS.html#ade226d0a495e134d589ffdc5baa45235">intParCB</a>;            <span class="comment">// push function arguments</span>
<a name="l00539"></a>00539 
<a name="l00541"></a>00541     <span class="comment">// ENCAPSULATED EXTERNAL SIMULATOR SUPPORT</span>
<a name="l00543"></a>00543 <span class="comment"></span>
<a name="l00544"></a><a class="code" href="structvmiIASAttrS.html#a5584459ba507c5c360525e719e923c1d">00544</a>     vmiEncapSimFn    <a class="code" href="structvmiIASAttrS.html#a5584459ba507c5c360525e719e923c1d">encapSimCB</a>;        <span class="comment">// simulate for a number of instructions</span>
<a name="l00545"></a><a class="code" href="structvmiIASAttrS.html#a434fa840ef1a55d1a298765792b0adc5">00545</a>     vmiEncapGetPCFn  <a class="code" href="structvmiIASAttrS.html#a434fa840ef1a55d1a298765792b0adc5">encapGetPCCB</a>;      <span class="comment">// get processor program counter</span>
<a name="l00546"></a><a class="code" href="structvmiIASAttrS.html#a1c023ec35e72c4f27c7aee1c4f4875b6">00546</a>     vmiEncapICountFn <a class="code" href="structvmiIASAttrS.html#a1c023ec35e72c4f27c7aee1c4f4875b6">encapICountCB</a>;     <span class="comment">// get processor instruction count</span>
<a name="l00547"></a>00547 
<a name="l00549"></a>00549     <span class="comment">// SIMULATOR ENVIRONMENT SUPPORT</span>
<a name="l00551"></a>00551 <span class="comment"></span>
<a name="l00552"></a><a class="code" href="structvmiIASAttrS.html#af51a0450e9ec0e2bce227ff9d4396fdd">00552</a>     vmiProcessorInfoFn <a class="code" href="structvmiIASAttrS.html#af51a0450e9ec0e2bce227ff9d4396fdd">procInfoCB</a>;         <span class="comment">// get the procInfo structure</span>
<a name="l00553"></a>00553 
<a name="l00555"></a>00555     <span class="comment">// CACHE SUPPORT ROUTINES</span>
<a name="l00557"></a>00557 <span class="comment"></span>
<a name="l00558"></a><a class="code" href="structvmiIASAttrS.html#aecfc80a27fce4290a44339a4f2250cbe">00558</a>     vmiCacheRegisterFn <a class="code" href="structvmiIASAttrS.html#aecfc80a27fce4290a44339a4f2250cbe">cacheRegisterCB</a>; <span class="comment">// register cache support functions</span>
<a name="l00559"></a>00559 
<a name="l00560"></a>00560 } <a class="code" href="structvmiIASAttrS.html">vmiIASAttr</a>;
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 <span class="preprocessor">#endif</span>
<a name="l00563"></a>00563 <span class="preprocessor"></span>
</pre></div></div>
<p><b>Copyright (c) 2005-2015 Imperas Software Ltd. All Rights Reserved.</b><br><br>
The contents of this file are provided under the Software License Agreement that you accepted before downloading this file.<br>
This header forms part of the Software but may be included and used unaltered in derivative works.<br>
For more information, please visit
<a href="http://www.OVPworld.org">www.OVPworld.org</a>
 or
 <a href="http://www.imperas.com">www.imperas.com</a>.</p>
