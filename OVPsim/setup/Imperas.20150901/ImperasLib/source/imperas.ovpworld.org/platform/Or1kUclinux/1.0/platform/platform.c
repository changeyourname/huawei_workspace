/*
 * Copyright (c) 2005-2015 Imperas Software Ltd., www.imperas.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string.h>

#include "icm/icmCpuManager.h"

#define SIM_ATTRS (ICM_ATTR_DEFAULT)

// Define base and extent of the UART peripheral
#define UART_LOW  0x90000000
#define UART_HIGH 0x90000007


//
// Main simulation routine
//
int main(int argc, char ** argv) {

    // Define default application to load onto processor
    const char *imageFile = "linux_sh.or32";
    struct stat statBuf;
    Uns64 portNumber;

    // check arguments on command line
    if(argc==2) {
        imageFile = argv[1];
        icmPrintf("%s: file to load %s\n", argv[0], argv[1]);
    } else if (argc>2) {
        icmPrintf("%s: too many arguments\n", argv[0]);
        return -1;
    }

    // Check the application file is available
    if (stat(imageFile, &statBuf) != 0) {
        icmPrintf("%s: Error cannot open %s\n", argv[0], imageFile);
        return -1;
    }

    // initialize OVPsim, enabling verbose mode to get statistics at end
    // of execution
    icmInitPlatform(ICM_VERSION, ICM_VERBOSE|ICM_STOP_ON_CTRLC, 0, 0, "platform");

    // ignore 'Info' messages generated by the OR1K model
    icmIgnoreMessage("OR1K_");

    ////////////////////////////////////////////////////////////////////////////
    // CONNECTIVITY OBJECTS
    ////////////////////////////////////////////////////////////////////////////

    // create the processor bus
    icmBusP bus = icmNewBus("bus1", 32);

    // declare a net for connection of the interrupt line
    icmNetP int1 = icmNewNet("int1");

    ////////////////////////////////////////////////////////////////////////////
    // MEMORY
    ////////////////////////////////////////////////////////////////////////////

    // create two memory regions mapping all memory except the uart registers
    icmMemoryP mem1 = icmNewMemory("mem1", ICM_PRIV_RWX, UART_LOW-1);
    icmMemoryP mem2 = icmNewMemory("mem2", ICM_PRIV_RWX, 0xffffffff-UART_HIGH-1);

    // connect memories to the bus
    icmConnectMemoryToBus(bus, "sp", mem1, 0x00000000);
    icmConnectMemoryToBus(bus, "sp", mem2, UART_HIGH+1);

    ////////////////////////////////////////////////////////////////////////////
    // MAIN PROCESSOR
    ////////////////////////////////////////////////////////////////////////////

    // instantiate main processor
    const char *or1kModel    = icmGetVlnvString(NULL, "ovpworld.org", "processor", "or1k", "1.0", "model");
    icmProcessorP processor = icmNewProcessor(
        "cpu1",             // CPU name
        "or1k",             // CPU type
        0,                  // CPU cpuId
        0,                  // CPU model flags
        32,                 // address bits
        or1kModel,          // model file
        "modelAttrs",       // morpher attributes
        SIM_ATTRS,          // enable tracing etc
        0,                  // user-defined attributes
        0,                  // semi-hosting file
        0                   // semi-hosting attributes
    );

    // connect the processor instruction and data busses to the bus
    icmConnectProcessorBusses(processor, bus, bus);

    // connect the processor interrupt port to the net
    icmConnectProcessorNet(processor, int1, "intr2", ICM_INPUT);

    // load the application executable file into processor memory space
    icmLoadProcessorMemory(processor, imageFile, ICM_LOAD_DEFAULT, False, True);

    ////////////////////////////////////////////////////////////////////////////
    // UART
    ////////////////////////////////////////////////////////////////////////////
    // create attributes to configure the UART PSE model
    icmAttrListP pseAttrs = icmNewAttrList();
    char *envPortNum = getenv("PORTNUM");
    if (envPortNum == NULL) {
        icmAddBoolAttr(pseAttrs, "console", 1);
    } else {
        portNumber = atoi(envPortNum);
        icmAddUns64Attr(pseAttrs, "portnum", portNumber);
    }
    icmAddBoolAttr(pseAttrs, "finishOnDisconnect", 1);

    // instantiate the uart peripheral
    const char *uartPseModel    = icmGetVlnvString(NULL, "national.ovpworld.org", "peripheral", "16550", "1.0", "pse");
    icmPseP uart = icmNewPSE("16550", uartPseModel, pseAttrs, NULL, NULL);

    // connect the uart port on the bus and define the address range it occupies
    icmConnectPSEBus(uart, bus, "bport1", False, UART_LOW, UART_HIGH);

    // connect the uart interrupt port to the net
    icmConnectPSENet(uart, int1, "intOut", ICM_OUTPUT);

    icmSetPSEdiagnosticLevel(uart, 1);

    ////////////////////////////////////////////////////////////////////////////
    // RUN SIMULATION OF PLATFORM
    ////////////////////////////////////////////////////////////////////////////
    icmProcessorP final = icmSimulatePlatform();

    // was simulation interrupted or did it complete
    if(final && (icmGetStopReason(final)==ICM_SR_INTERRUPT)) {
        icmPrintf("*** simulation interrupted\n");
    }

    icmTerminate();

    return 0;
}
