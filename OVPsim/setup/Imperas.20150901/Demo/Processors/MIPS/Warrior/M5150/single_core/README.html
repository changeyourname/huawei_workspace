<html>
<title>OVP M5150 Single Core Demo</title>
<head><style>
	body {
		text-align: center;
	}
	#page-wrap {
		text-align: left;
		 width: 90%;
		 margin: 0 auto;
	 }
	#checkFiles {
		text-align: left;
		width: 90%;
		margin: 0 auto;
	 }
	 
</style></head>
<body><div id='page-wrap'>
<h1>Demonstration README - Single Core Example</h1>
<p>Contents:</p>
<ul>
<li><a href=#rmWriteSectionSingleIntro >Single core variant: M5150</a><br/></li>
<li><a href=#rmWriteSectionRun >Running the simulation</a><br/></li>
<li><a href=#rmWriteSectionResults >Interpreting results</a><br/></li>
<li><a href=#rmWriteSectionBuild >Re-Building Platforms and Applications</a><br/></li>
<li><a href=#rmWriteSectionGdb >Debugging with GDB</a><br/></li>
<li><a href=#rmWriteSectionIgui >Debugging with the Imperas GUI (iGui)</a><br/></li>
<li><a href=#rmWriteSectionISS >The Imperas Instruction Set Simulator (ISS)</a><br/></li>
</ul>
<hr>
<a id='rmWriteSectionSingleIntro'>
<h1>Single core variant: M5150</h1>
</a>
<p>
		This demonstration shows running a simulation of a platform containing a single <a href=http://www.ovpworld.org/processor-model-variant-mips-warrior-m5150 title='look at OVPWorld page on this variant'>MIPS M5150</a>
		processor instance, and a memory map ranging from #00000000 to #FFFFFFFF.
	</p>
<p><img src=../../../../pictures/Single_Run.jpg alt=IMG_SINGLE_RUN height=400></p>
<p>
		This platform can then be used to execute pre-compiled applications; the 
		following are provided as examples:
	</p>
<ul>
<li><a href=../../../Applications/peakSpeed2/peakSpeed2.c title='look at application source'>peakSpeed2.c</a> (<a href=../../../Applications/peakSpeed2 title='look at application directory'>../../../Applications/peakSpeed2/peakSpeed2.CS_UMIPS-O0-g.elf</a>)</li>
<li><a href=../../../Applications/dhrystone/dhrystone.c title='look at application source'>dhrystone.c</a> (<a href=../../../Applications/dhrystone title='look at application directory'>../../../Applications/dhrystone/dhrystone.CS_UMIPS-O3-g.elf</a>)</li>
<li><a href=../../../Applications/linpack/linpack.c title='look at application source'>linpack.c</a> (<a href=../../../Applications/linpack title='look at application directory'>../../../Applications/linpack/linpack.CS_UMIPS-O0-g.elf</a>)</li>
<li><a href=../../../Applications/fibonacci/fibonacci.c title='look at application source'>fibonacci.c</a> (<a href=../../../Applications/fibonacci title='look at application directory'>../../../Applications/fibonacci/fibonacci.CS_UMIPS-O3-g.elf</a>)</li>
</ul>
<p>
		After each application has executed, a simulation summary will be printed,
		indicating the number of instructions executed, and the performance of the
		simulation in terms of Millions of simulated Instructions executed Per
		Second (MIPS)
		<br/><br/>
		This demonstration actually runs using the Imperas Instruction Set Simulator (ISS) but a platform written in C very similar to the one being used in this demonstration can be found
		in the <a href=../../../../../../Examples/Platforms/simple/platform title='look at platform example source/makefile'>Examples/Platforms/Single directory</a> that is installed in an OVPsim or Imperas install. There is more information on the ISS below.
		<br/><br/>
		The C platform can be compiled with GCC under Linux or
		using MinGW/MSYS from http://www.mingw.org under Windows.
		The version of <a href=http://www.ovpworld.org/resources/windows title='look at MinGW/MSYS download page on OVPWorld'>MinGW/MSYS</a> that we use is available here.
	</p>
<hr>
<a id='rmWriteSectionRun'>
<h1>Running the simulation</h1>
</a>
<h2>From a Microsoft window manager or Linux / MSYS shell</h2>
<p>
		Launch the platform with a pre-compiled application; in Windows by double 
		clicking one of the batch files (.bat) or in Linux / MSYS by executing one of the shell 
		scripts (.sh).
		<br/><br/>
		The scripts will be available dependent upon the applications available:
	</p>
<ul>
<li>Run_PeakSpeed2.bat (Windows)</br>Run_PeakSpeed2.sh (Linux/MSYS)</li>
<li>Run_Dhrystone.bat (Windows)</br>Run_Dhrystone.sh (Linux/MSYS)</li>
<li>Run_Linpack.bat (Windows)</br>Run_Linpack.sh (Linux/MSYS)</li>
<li>Run_Fibonacci.bat (Windows)</br>Run_Fibonacci.sh (Linux/MSYS)</li>
</ul>
<p>The simulation will run and print statistics upon completion.</p>
<h2>From the command line</h2>
<p>
		If running a DOS command window, or a MSYS shell, or a Linux shell, simply change
		directory to an appropriate directory, then type the name of the ISS executable, iss.exe or issdemo.exe (dependent on installation), 
		provide the name of the variant you want after the --variant argument, and provide the
		application after the --program argument, for example:
		<br/><br/>
		cmd > issdemo.exe --variant M5150 --numprocessors 1   --program ../../../Applications/peakSpeed2/peakSpeed2.CS_UMIPS-O0-g.elf
		<br/><br/>
		Note that often other options like --processorname and parameters such as --parameter endian=little, are also needed. Look at the above script files to see what is needed for a specific variant.
		<br/><br/>
		You can use issdemo.exe --help to see more options.
		<br/><br/>
		The simulation will run and print statistics upon completion.
	</p>
<hr>
<a id='rmWriteSectionResults'>
<h1>Interpreting results</h1>
</a>
<p>
		At the end of simulation, a number of statistics will be printed.
		Amongst the statistical information which is reported, are the number
		of 'Simulated instructions' and the 'Simulated MIPS'.
	</p>
<p><img src=../../../../pictures/Single_Run_Output.jpg alt=IMG_RUNOUTPUT height=200></p>
<p>
		The 'Simulated instructions' will vary depending upon the application being
		executed, this count indicates the number of simulated processor
		instructions for the processors in the platform.
		<br/><br>
		The 'Simulated MIPS' will be a measure of the number of 'Simulated
		instructions' over the host elapsed time.
		The simulation must run for around 1 second of simulated time in order to print 
		simulated MIPS statistics.
		<br/><br>
		If you have multiple processors in your simulation, there will be a statistics sections for
		each processor, and then a summary for the overall simulation run.
	</p>
<hr>
<a id='rmWriteSectionBuild'>
<h1>Re-Building Platforms and Applications</h1>
</a>
<p>
		In order to rebuild a full product install must have been carried out. This may
		be the OVP 'OVPsim' package or one of the Imperas Professional Tools
		packages (*SDK or *DEV). 
		<br/><br>
		A processor cross compiler toolchain package must be installed to allow the 
		applications to be rebuilt.
	</p>
<p>
			An external toolchain to support this processor variant must be used. A set of Makefiles  
		    so support this processor variant may be available from OVPWorld, with a package name 
		    extension similar to <b>NAME..toolsupport.YYYYMMDD.v.OS.exe</b> Please check the requirements.		
			<br/><br>
		</p>
<p>
		A Makefile is supplied in the <a href=../../../../../../Examples/Platforms/simple/platform title='look at platform example source/makefile'>../Examples/Platforms/simple/platform directory</a> 
		that will perform the rebuilding of the platform 
		executable and also see the <a href=../../../Applications/peakSpeed2 title='look at the applications directory'>applications directory</a> 
		for re-building the application ELF files.
	</p>
<h3>Re-building Platform</h3>
<p>
		The platform can be compiled using MSYS/MinGW 
		under Windows, and GCC under Linux.
		<br/><br>
		The compilation can be performed using the following command lines:
		<br/><br>
		<b>Windows Command shell</b><br>
		This requires an MSYS environment setup<br>
		>mingw32-make -f \%IMPERAS_HOME\%/ImperasLib/buildutils/Makefile.platform ^<br>
				  &nbsp;&nbsp;&nbsp;&nbsp;SRC=platform.c ^<br>
				  &nbsp;&nbsp;&nbsp;&nbsp;NOVLNV=1<br>
		<br>
		<b>Linux or Windows MSYS shell (if you have an MSYS environment set up)</b><br>
		>make -f ${IMPERAS_HOME}/ImperasLib/buildutils/Makefile.platform \<br>
				 &nbsp;&nbsp;&nbsp;&nbsp;SRC=platform.c \<br>
				 &nbsp;&nbsp;&nbsp;&nbsp;NOVLNV=1<br>
	</p>
<h3>Re-building Application</h3>
<p>
		The applications were built using a Cross Compiler toolchain, that may be 
		available from the OVPWorld website, which includes an CS_UMIPS.makefile.include
		that is used to setup a basic build environment for that toolchain. This can 
		be modified to use alternative compiler flags.
	</p>
<hr>
<a id='rmWriteSectionGdb'>
<h1>Debugging with GDB</h1>
</a>
<p>
		This demo provides example scripts that allow the same simulation platform
		to be executed and a GDB debugger connected to the RSP port to allow the 
		debugging of any application running on the platform. 
	</p>
<p><img src=../../../../pictures/Single_Debug_GDB.jpg alt=IMG_SINGLE_DEBUG_GDB height=400></p>
<p>
		The scripts will launch GDB in a new console window. You then interact with the GDB in that console, typing 'c' to continue for example.
		When finished use 'quit' to exit the simulation.
		The following GDB debug scripts are available for this example:
	</p>
<ul>
<li>Debug_GDB_Dhrystone.bat (Windows)</br>Debug_GDB_Dhrystone.sh (Linux/MSYS)</li>
</ul>
<p>
		The GDB is expected to be found in one of the CrossCompiler or $IMPERAS_HOME/lib/$IMPERAS_ARCH/gdb directories. If it is
		not available the script will fail. (See Cross Compiler Toolchains below.)
		<br/><br>
		If available, a .key file gives a minimal set of commands; that, if used, will 
		run the simulation under the debugger.
	</p>
<hr>
<a id='rmWriteSectionIgui'>
<h1>Debugging with the Imperas GUI (iGui)</h1>
</a>
<p>
		To run with the Imperas GUI (iGui) use one of the example scripts:
	</p>
<ul>
<li>Debug_iGui_Dhrystone.bat (Windows)</br>Debug_iGui_Dhrystone.sh (Linux/MSYS)</li>
</ul>
<p>
		This will run the simulation and start up the Imperas GUI to control it. 
		Several windows should open, allowing control of the simulation. 
	</p>
<p><img src=../../../../pictures/Single_Debug_iGui.jpg alt=IMG_SINGLE_DEBUG_IGUI height=400></p>
<p>
		iGui is an easy to use Graphical User Interface written in tcl/TK to provide very quick and easy use of debuggers. 
		It is modeled on the DDD debugger that controls GDB and which is a standard tool within Linux distributions.
		iGui connects to either a standard GDB or the Imperas Multi-Processor Debugger (MPD).
	</p>
<p>
		When you start up iGui an initialization file is used. It is in this directory and is called '.iguirc'.
		It selects, opens and positions several windows. When you change iGui window settings and sizes this data can be saved in the .iguirc from run to run.
		It can be saved from the iGui->File->Save_ini menu.
	</p>
<p>
		For this demonstration, the specific GDB for the MIPS M5150 is used as the debugger.
		There is also a gdb start up file being used, called '(programname).gdb'. It sets up a breakpoint in the application source on main, one on exit, sets where to find the .c source of the application, and then runs to the first breakpoint.
		So that when you start this demonstration, the simulator, gdb, and iGui will startup, connect, and run to the breakpoint on main.
	</p>
<p><img src=../../../../pictures/Single_Debug_iGui_Info.jpg alt=IMG_SINGLE_DEBUG_IGUI_INFO height=400></p>
<p>
		You will see several windows open. In the main window console is the source pane, the assembler or machine code pane, the console pane and command line input console.
		GDB or MPD (dependent on which debugger is connected) commands can be typed into the command line console.
	</p>
<p>
		You can scroll the source window and double click on executable source lines to add breakpoints.
		You can get a list of other source files of this application using the iGui->Source->Files menu. 
		You then double click on a file name to access that file. This allows you to set breakpoints on code you have not yet executed.
		As you add breakpoints either by double clicking the source or by adding them in text via the command console window - they appear in the Breakpoints window.
	</p>
<p>
		There are also windows showing the variables in the current function, the current stack frame, and the global registers for this processor.
	</p>
<p>
		Click on the command tool windows 'Step' command and the debugger steps one line.
		Note that as the debugger runs and stops, the windows update and any changes in the register, stack, variables windows are highlighted if their values have changed.
		Click on 'Next' or 'Step' to move run the program a line. You can also use the assembler level stepi and nexti.
		There are also the normal GDB commands Up, Down, Where, Finish etc.
	</p>
<p>
		Note that when you run the simulation from iGui the output from the simulation still is output in the window that you started the simulation from.
	</p>
<p>
		There are several other windows available from the main console window menu - and note that some commands do not operate when iGui is connected to a GDB.
		These options are for use with MPD which is used for debugging software running on multiple cores and for co-debug of software and hardware platforms.
	</p>
<p>
		When finished, click on 'Quit' in the command tool to quit.
	</p>
<hr>
<a id='rmWriteSectionISS'>
<h1>The Imperas Instruction Set Simulator (ISS)</h1>
</a>
<p>
		The demonstrations provided for single core processors use the Imperas ISS to create a simple platform and run the cross compiled target applications.
	</p>
<p>
		The Imperas ISS is often the first simulation product used in an embedded software development project.
		The Imperas ISS allows the development and debug of code for the target architecture on an x86/x64 host PC with the minimum of setup and effort.
		It simply requires the cross compilation of your application and running the ISS with an argument to specify the name of the application object.
	</p>
<p><img src=../../../../pictures/ISS_Overview.jpg alt=IMG_ISS_OVERVIEW height=400></p>
<p>
		The ISS makes use of the Imperas OVP Fast Processor Model library providing access to over 130 different instruction accurate embedded CPU model variants from the Imagination/MIPS 24Kc to the ARM Cortex-A57MPx4 quad core 64 bit processor.
		The ISS product package comes with all these CPU models and example usage of them.
	</p>
<h3>Imperas ISS Detailed Features</h3>
<ul>
<li>Released to run in x86 32 bit Windows/Linux and x64 64 bit Windows/Linux environments</li>
<li>Includes the full library of all publicly released Imperas OVP Fast Processor Models</li>
<li>Includes a GDB debugger for each CPU family</li>
<li>Includes the Imperas Graphical User Interface (iGui) to provide full source code debug</li>
<li>Configurable trace subsystem to provide instruction and register tracing</li>
<li>Loads .elf file binaries directly</li>
<li>Allows one instance of a single or multi-core CPU with full memory construction</li>
<li>Uses built in semi-hosting to support library functions such as printf and fopen, and can access host native resources</li>
<li>Can be run interactively or in script/batch mode for regression testing</li>
<li>Includes Imperas Just-In-Time (JIT) Code Morphing high performance CPU simulator technology</li>
<li>Works with Eclipse/CDT GUI</li>
</ul>
<p>
		For more information on the Imperas ISS, visit the <a href=http://www.imperas.com/iss title='look at the ISS page on Imperas.com'>ISS page</a> on the Imperas web site.
	</p>
<p>
		To see the command line options available for the ISS, type 'iss.exe or issdemo.exe -help' to see a list.
	</p>
<hr>
<p>###</p>
</div></body>
</html>
