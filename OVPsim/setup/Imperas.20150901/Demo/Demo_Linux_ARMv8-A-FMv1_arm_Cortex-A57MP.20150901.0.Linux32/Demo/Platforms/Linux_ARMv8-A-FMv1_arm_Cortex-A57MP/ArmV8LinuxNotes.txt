Notes on Running Imperas ARMv8 Linux Platforms


RUNNING ARMv8 LINUX
---------------------

Imperas provides a platform that implements the Foundation Model v1
memory map described in the ARM document DUI 0677C. The v1 memory map
is a very simple model with just memory, UARTS, an ethernet device and
a VIRTIO block device.

The Imperas model is in:
  $IMPERAS_HOME/ImperasLib/source/arm.ovpworld.org/platform/ARMv8-A-FMv1

The model also includes a "SmartLoaderArm64Linux" pseudo-peripheral that
may be used for configuring the memory to boot Linux in lieu of having
boot loader code. The smartLoader may be disabled when boot loader code
is available.


Linux_ARMv8-A-FMv1_arm_Cortex-A57MP DEMO PACKAGE
-------------------------------------------------------

Imperas provides the Linux_ARMv8-A-FMv1_arm_Cortex-A57MP demo
package that includes a pre-compiled kernel, device tree blob, initrd
file, and scripts to run.

To boot Linux, install the Linux_ARMv8-A-FMv1_arm_Cortex-A57MP
demo package and run it as follows (this assumes the Imperas tools and
the demo package have already been installed and setup):

  # cd to the Demo directory
  cd $IMPERAS_HOME/Demo/Platforms/Linux_ARMv8-A-FMv1_arm_Cortex-A57MP
  # run using the script provided
  ./RUN_ARMv8-A-FMv1_arm_Cortex_A57MPx4.sh

This will boot Linux with the supplied initrd ram disk and open 2
terminals connected to simulated UARTs. The initrd is configured to start
login shells on the two simulated terminals. Just login with the user id
"root", no password is required.

To terminate simulation simply close the uart0 terminal window. Since only
a ramdisk is being used there is no need to shut Linux down cleanly, but
this also means all changes to the ramdisk are lost when simulation ends.

See the README.txt file in the demo directory for more info, including
instructions on how to modify the provided initrd.


RUNNING THE BENCHMARKS PROVIDED ON THE INITRD
---------------------------------------------

The initrd includes example benchmarks in the /benchmarks directory:
  /benchmarks/arm64Linux - the benchmarks compiled for AArch64
  /benchmarks/armLinux   - the benchmarks compiled for AArch32
  /benchmarks/source     - the benchmark source

There are Makefiles in the arm64Linux and armLinux directories showing how
the benchmarks were compiled. However there is no gcc on the initrd so
you will not be able to compile the benchmarks directly. You can unpack
the initrd image on your host, cross-compile the benchmarks then repack
the image if you would like to re-compile the executables.

There is a README.txt file that gives a brief description of the
benchmarks. Most of the benchmarks accept a single numeric argument that
may be used to control how long they run.

Some scripts are provided to run the benchmarks:
  runAll.sh:        Runs all the benchmarks consecutively.  
  parallel.sh:      Runs 4 integer benchmarks simultaneously
  parallelFloat.sh: Runs 4 floating point benchmarks simultaneously
  loop.sh:          Runs a demo multiple times in a row
  mixed.sh:         Runs AArch64 and 32 benchmarks simultaneously


RUNNING THE SIMULATOR WITH DIFFERENT OPTIONS
--------------------------------------------

To simply run the platform directly without using the script, thus
gaining more control over the simulation, use the command:

  ${IMPERAS_VLNV}/arm.ovpworld.org/platform/ARMv8-A-FMv1/1.0/platform.${IMPERAS_ARCH}.exe \
    --startaddress 0x80000000   \
    --override ARMv8-A-FMv1/smartLoader/kernel=Image  \
    --override ARMv8-A-FMv1/smartLoader/initrd=initrd.arm64.img \
    --override ARMv8-A-FMv1/smartLoader/dtb=foundation-v8.dtb   \
    --override ARMv8-A-FMv1/uart0/console=1 \
    --override ARMv8-A-FMv1/uart1/console=1 \
    --output imperas.log --verbose

We will provide example commands of this type in the rest of this document.

To see what command line arguments are available use --help:
  ${IMPERAS_VLNV}/arm.ovpworld.org/platform/ARMv8-A-FMv1/1.0/platform.${IMPERAS_ARCH}.exe --help

To see what overrides are available use --showoverrides:
  ${IMPERAS_VLNV}/arm.ovpworld.org/platform/ARMv8-A-FMv1/1.0/platform.${IMPERAS_ARCH}.exe --showoverrides
	

RUNNING AARCH64 LINUX WITH A ROOTFS RATHER THAN AN INITRD
---------------------------------------------------------

The platform model includes a VIRTIO block device peripheral, allowing
the use of a rootfs rather than the initrd provided with the demo.

There are several prebuilt root file system images for AArch64 Linux available at:
  http://releases.linaro.org/latest/openembedded/aarch64

As an example, to run with the Linaro minimal-armv8 image do the following:

  wget http://releases.linaro.org/14.05/openembedded/aarch64/vexpress64-openembedded_minimal-armv8-gcc-4.8_20140530-656.img.gz
  gunzip vexpress64-openembedded_minimal-armv8-gcc-4.8_20140530-656.img.gz
  ${IMPERAS_VLNV}/arm.ovpworld.org/platform/ARMv8-A-FMv1/1.0/platform.${IMPERAS_ARCH}.exe \
    --startaddress 0x80000000   \
    --override ARMv8-A-FMv1/smartLoader/kernel=Image  \
    --override ARMv8-A-FMv1/smartLoader/dtb=foundation-v8.dtb   \
    --override ARMv8-A-FMv1/uart0/console=1 \
    --override ARMv8-A-FMv1/uart1/console=1 \
    --output imperas.log --verbose \
    \
    --override ARMv8-A-FMv1/smartLoader/append="rw root=/dev/vda2"   \
    --override ARMv8-A-FMv1/vbd0/VB_DRIVE=vexpress64-openembedded_minimal-armv8-gcc-4.8_20140530-656.img  \
    --override ARMv8-A-FMv1/vbd0/VB_DRIVE_DELTA=1 

We have removed the smartLoader initrd override and replaced it with
the final 3 command line arguments that:

1) Append to the default kernel command line commands to specify the
   root is on /dev/vda2 and is read-write.

2) Configure the Virtio block device peripheral to use the downloaded
   image file.

3) Set the VB_DRIVE_DELTA option on the Virtio block device to prevent
   the model from modifying the image on the host disk drive. If this option
   is not used the image file will be modified by the simulation. When
   VB_DRIVE_DELTA is not specified you must be careful to shut Linux
   down cleanly with the "halt" command to prevent corruption of the
   disk image. Once the kernel halts just close the uart0 window and the
   simulation will terminate.

One tip is to not use VB_DRIVE_DELTA the first time you boot with the
image so that the image is updated with cache files and RSA keys, thus
saving time on subsequent boots.

Note that these image files are different from the initrd image files
and cannot be manipulated using the utilities provided with the demo. A
good description of how to use standard Linux utilities to modify these
images may be found here:
  http://nfolamp.wordpress.com/2010/08/16/mounting-raw-image-files-and-kpartx/

The simulation uses only the second partition on the image - the first
partition is not used.


RUNNING JAVA BENCHMARKS
-----------------------

By downloading a full image that includes an installation of java,
you may run java in the simulated Linux. This has been tested using the
following image:
  vexpress64-openembedded_leg-java-armv8-gcc-4.8_20140530-656.img.gz

An interesting set of benchmarks may be found here:
  http://www.dacapobench.org/

The following commands will download the image and benchmarks and add
the benchmarks to the image:

  # download and decompress the Linux rootfs image
  wget http://releases.linaro.org/14.05/openembedded/aarch64/vexpress64-openembedded_leg-java-armv8-gcc-4.8_20140530-656.img.gz
  gunzip vexpress64-openembedded_leg-java-armv8-gcc-4.8_20140530-656.img.gz

  # download the benchmarks
  wget http://sourceforge.net/projects/dacapobench/files/latest/download?source=files

  # mount the 2nd partition of the image on the host
  mkdir leg-java
  sudo /sbin/kpartx -a -v vexpress64-openembedded_leg-java-armv8-gcc-4.8_20140530-656.img
  # The previous command will print out the correct name in /dev/mapper to use, e.g. loop0p2
  sudo mount /dev/mapper/loop0p2 leg-java

  # copy the benchmarks to the image
  sudo mkdir leg-java/javaBench
  sudo cp dacapo-9.12-bach.jar leg-java/javaBench

  # unmount the image
  sudo umount leg-java
  sudo /sbin/kpartx -d -v vexpress64-openembedded_leg-java-armv8-gcc-4.8_20140530-656.img.gz
  
Note that when using an NFS disk and sudo there can be problems with
file permissions, because root has no special permissions for an NFS
disk on another machine. It is suggested that you do these operations
on a local disk.

Now we can run with the rootfs as shown above (just change the name of
the image file used). Then in the simulated image do the following to
see a list of benchmarks:
  cd /javaBench
  java -jar dacapo-9.12-bach.jar -l

And to run a benchmark (e.g. avrora):
  java -jar dacapo-9.12-bach.jar avrora


RE-BUILDING THE LINUX KERNEL
----------------------------

The pre-compiled Linux kernel was built from source downloaded from the
linaro.org site and built as follows:
	git clone git://git.linaro.org/kernel/linux-linaro-tracking.git
	cd linux-linaro-tracking
	git checkout ll_20140321.0
	ARCH=arm64 scripts/kconfig/merge_config.sh \
		linaro/configs/linaro-base.conf \
		linaro/configs/linaro-base64.conf \
		linaro/configs/distribution.conf \
		linaro/configs/vexpress64.conf \
		linaro/configs/kvm-host.conf \
		linaro/configs/kvm-guest.conf
	make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- CONFIG_DEBUG_INFO=1 Image dtbs

These commands are based on the instructions found at:
	http://releases.linaro.org/14.05/openembedded/aarch64

This assumes the aarch64-linux-gnu cross compiler is on the path and that
all the Linux utilities required for standard Linux builds are present.

After running the commands above, the kernel image and device tree blob
used in the demo may be found in:
	arch/arm64/boot/Image
	arch/arm64/boot/dts/foundation-v8.dtb

In addition, the elf file for the kernel may be found in:
	vmlinux

The vmlinux file is needed to do kernel debugging as it contains the
symbolic and debug info for the kernel image.


DEBUGGING THE KERNEL
--------------------

Debug of the kernel may done by adding the following command line options
when starting the simulator:
	--symbolfile vmlinux --mpdgui

This tells the simulator where to find the symbols for the kernel and
starts the Imperas Graphical User Interface. (If you are running with
an rsh to a remote computer make sure the DISPLAY environment variable
is set appropriately.)

If you have not re-built the kernel you will need to download the
source. If the source is not in the current directory you will need
to tell gdb where to look for the source using the "dir" command in
the debugger.



##




